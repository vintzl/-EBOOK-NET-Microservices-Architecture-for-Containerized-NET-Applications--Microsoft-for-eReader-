<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="id_Toc534713605" class="block_16">Development Process for Docker-Based Applications</p>
	<p class="block_26">Develop containerized .NET applications the way you like, either IDE focused with Visual Studio and Visual Studio tools for Docker or CLI/Editor focused with Docker CLI and Visual Studio Code.</p>
	<h2 id="id_Toc534713606" class="block_18">Development environment for Docker apps</h2>
	<h3 id="id_Toc534713607" class="block_19">Development tool choices: IDE or editor</h3>
	<p class="block_14">Whether you prefer a full and powerful IDE or a lightweight and agile editor, Microsoft has tools that you can use for developing Docker applications.</p>
	<p class="block_14"><b class="calibre5">Visual Studio (for Windows).</b> When developing Docker-based applications with Visual Studio, it’s recommended to use Visual Studio 2017 version 15.7 or later, that comes with tools for Docker already built-in. The tools for Docker let you develop, run, and validate your applications directly in the target Docker environment. You can press F5 to run and debug your application (single container or multiple containers) directly into a Docker host, or press CTRL+F5 to edit and refresh your application without having to rebuild the container. This is the most powerful development choice for Docker-based apps.</p>
	<p class="block_14"><b class="calibre5">Visual Studio for Mac.</b> It’s an IDE, evolution of Xamarin Studio, running in macOS and supports Docker since mid-2017. This should be the preferred choice for developers working in Mac machines who also want to use a powerful IDE.</p>
	<p class="block_14"><b class="calibre5">Visual Studio Code and Docker CLI</b>. If you prefer a lightweight and cross-platform editor that supports any development language, you can use Microsoft Visual Studio Code (VS Code) and the Docker CLI. This is a cross-platform development approach for Mac, Linux, and Windows. Additionally, Visual Studio Code supports extensions for Docker such as IntelliSense for Dockerfiles and shortcut tasks to run Docker commands from the editor.</p>
	<p class="block_17"><span class="text_5">By installing </span><a href="https://www.docker.com/community-edition" class="text_4">Docker Community Edition (CE)</a><span class="text_5"> tools, you can use a single Docker CLI to build apps for both Windows and Linux.</span></p>
	<h3 id="id_Toc534713608" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Visual Studio</span><span class="text_">. Official site.<br class="calibre6"/></span><a href="https://visualstudio.microsoft.com/vs/" class="text_1">https://visualstudio.microsoft.com/vs/</a></li>
	<li class="block_20"><span class="text_2">Visual Studio Code</span><span class="text_">. Official site.<br class="calibre6"/></span><a href="https://code.visualstudio.com/download" class="text_1">https://code.visualstudio.com/download</a></li>
	<li class="block_20"><span class="text_2">Docker Community Edition (CE) for Mac and Windows</span><span class="text_"><br class="calibre6"/></span><a href="https://www.docker.com/community-edition" class="text_1">https://www.docker.com/community-editions</a></li>
</ul>
	<h2 id="id_Toc534713609" class="block_18">.NET languages and frameworks for Docker containers</h2>
	<p class="block_17"><span class="text_5">As mentioned in earlier sections of this guide, you can use .NET Framework, .NET Core, or the open-source Mono project when developing Docker containerized .NET applications. You can develop in C#, F#, or Visual Basic when targeting Linux or Windows Containers, depending on which .NET framework is in use. For more details about.NET languages, see the blog post </span><a href="https://blogs.msdn.microsoft.com/dotnet/2017/02/01/the-net-language-strategy/" class="text_4">The .NET Language Strategy</a><span class="text_5">.</span></p>
	<h1 id="id_Toc534713610" class="block_24">Development workflow for Docker apps</h1>
	<p class="block_14">The application development life cycle starts at your computer, as a developer, where you code the application using your preferred language and test it locally. With this workflow, no matter which language, framework, and platform you choose, you’re always developing and testing Docker containers, but doing so locally.</p>
	<p class="block_14">Each container (an instance of a Docker image) includes the following components:</p>
	<ul class="list_">
	<li class="block_25">An operating system selection, for example, a Linux distribution, Windows Nano Server, or Windows Server Core.</li>
	<li class="block_25">Files added during development, for example, source code and application binaries.</li>
	<li class="block_25">Configuration information, such as environment settings and dependencies.</li>
</ul>
	<h2 id="id_Toc534713611" class="block_18">Workflow for developing Docker container-based applications</h2>
	<p class="block_14">This section describes the <i class="calibre15">inner-loop</i> development workflow for Docker container-based applications. The inner-loop workflow means it’s not considering the broader DevOps workflow, that can include up to production deployment, and just focuses on the development work done on the developer’s computer. The initial steps to set up the environment aren’t included, since those steps are done only once.</p>
	<p class="block_14">An application is composed of your own services plus additional libraries (dependencies). The following are the basic steps you usually take when building a Docker application, as illustrated in Figure 5-1.</p>
	<p class="block_14"><img src="images/image-39.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image1.png" class="calibre50"/></p>
	<p class="block_23"><span class="text_6">Figure 5-1.</span><i class="calibre8"> Step-by-step workflow for developing Docker containerized apps</i></p>
	<p class="block_14">In this section, this whole process is detailed and every major step is explained by focusing on a Visual Studio environment.</p>
	<p class="block_17"><span class="text_5">When you’re using an editor/CLI development approach (for example, Visual Studio Code plus Docker CLI on macOS or Windows), you need to know every step, generally in more detail than if you’re using Visual Studio. For more information about working in a CLI environment, see the e-book </span><a href="https://aka.ms/dockerlifecycleebook/" class="text_4">Containerized Docker Application lifecycle with Microsoft Platforms and Tools</a><span class="text_5">.</span></p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.10.18_PM.png" alt="Image" class="calibre51"/>When you’re using Visual Studio 2017, many of those steps are handled for you, which dramatically improves your productivity. This is especially true when you’re using Visual Studio 2017 and targeting multi-container applications. For instance, with just one mouse click, Visual Studio adds the Dockerfile and docker-compose.yml file to your projects with the configuration for your application. When you run the application in Visual Studio, it builds the Docker image and runs the multi-container application directly in Docker; it even allows you to debug several containers at once. These features will boost your development speed.</p>
	<p class="block_14">However, just because Visual Studio makes those steps automatic doesn’t mean that you don’t need to know what’s going on underneath with Docker. Therefore, the following guidance details every step.</p>
	<p class="block_14">Developing a Docker application is similar to the way you develop an application without Docker. The difference is that while developing for Docker, you’re deploying and testing your application or services running within Docker containers in your local environment (either a Linux VM setup by Docker or directly Windows if using Windows Containers).</p>
	<h3 id="id_Toc534713613" class="block_19">Set up your local environment with Visual Studio</h3>
	<p class="block_17"><span class="text_5">To begin, make sure you have </span><a href="https://docs.docker.com/docker-for-windows/" class="text_4">Docker Community Edition (CE)</a><span class="text_5"> for Windows installed, as explained in the following instructions:</span></p>
	<p class="block_17"><a href="https://docs.docker.com/docker-for-windows/" class="text_4">Get started with Docker CE for Windows</a></p>
	<p class="block_14">In addition, you need Visual Studio 2017 version 15.7 or later, with the <b class="calibre5">.NET Core cross-platform development</b> workload installed, as shown in Figure 5-2.</p>
	<p class="block_14"><img src="images/image-40.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image3.png" class="calibre52"/></p>
	<p class="block_23"><span class="text_6">Figure 5-2</span><i class="calibre8">. Selecting the </i><span class="text_6">.NET Core cross-platform development</span><i class="calibre8"> workload during Visual Studio 2017 setup</i></p>
	<p class="block_14">You can start coding your application in plain .NET (usually in .NET Core if you’re planning to use containers) even before enabling Docker in your application and deploying and testing in Docker. However, it is recommended that you start working on Docker as soon as possible, because that will be the real environment and any issues can be discovered as soon as possible. This is encouraged because Visual Studio makes it so easy to work with Docker that it almost feels transparent—the best example when debugging multi-container applications from Visual Studio.</p>
	<h3 id="id_Toc534713614" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Get started with Docker CE for Windows</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.docker.com/docker-for-windows/" class="text_1">https://docs.docker.com/docker-for-windows/</a></li>
	<li class="block_20"><span class="text_"><img src="images/Screen_Shot_2019-01-15_at_6.10.43_PM.png" alt="Image" class="calibre53"/></span><span class="text_2">Visual Studio 2017</span><span class="text_"><br class="calibre6"/></span><a href="https://aka.ms/vsdownload?utm_source=mscom&amp;utm_campaign=msdocs" class="text_1">https://visualstudio.microsoft.com/downloads/</a></li>
</ul>
	<p class="block_14">You need a Dockerfile for each custom image you want to build; you also need a Dockerfile for each container to be deployed, whether you deploy automatically from Visual Studio or manually using the Docker CLI (docker run and docker-compose commands). If your application contains a single custom service, you need a single Dockerfile. If your application contains multiple services (as in a microservices architecture), you need one Dockerfile for each service.</p>
	<p class="block_14">The Dockerfile is placed in the root folder of your application or service. It contains the commands that tell Docker how to set up and run your application or service in a container. You can manually create a Dockerfile in code and add it to your project along with your .NET dependencies.</p>
	<p class="block_14">With Visual Studio and its tools for Docker, this task requires only a few mouse clicks. When you create a new project in Visual Studio 2017, there’s an option named <b class="calibre5">Enable Container (Docker) Support</b>, as shown in Figure 5-3.</p>
	<p class="block_14"><img src="images/image-41.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image5.png" class="calibre54"/></p>
	<p class="block_23"><span class="text_6">Figure 5-3</span><i class="calibre8">. Enabling Docker Support when creating a new ASP.NET Core project in Visual Studio 2017</i></p>
	<p class="block_14">You can also enable Docker support on an existing ASP.NET Core web app project by right-clicking the project in <b class="calibre5">Solution Explorer</b> and selecting <b class="calibre5">Add</b> &gt; <b class="calibre5">Docker Support</b>, as shown in Figure 5-4.</p>
	<p class="block_14"><img src="images/image-42.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image6.png" class="calibre32"/></p>
	<p class="block_23"><span class="text_6">Figure 5-4</span><i class="calibre8">. Enabling Docker support in an existing Visual Studio 2017 project</i></p>
	<p class="block_14">This action adds a <i class="calibre15">Dockerfile</i> to the project with the required configuration, and is only available on ASP.NET Core projects.</p>
	<p class="block_14">In a similar fashion, Visual Studio can also add a docker-compose.yml file for the whole solution with the option <b class="calibre5">Add &gt; Container Orchestrator Support</b>. In step 4, we’ll explore this option in greater detail.</p>
	<h3 id="id_Toc534713616" class="block_19">Using an existing official .NET Docker image</h3>
	<p class="block_15"><span class="text_12">You usually build a custom image for your container on top of a base image you get from an official repository like the </span><a href="https://hub.docker.com/" class="text_14">Docker Hub</a><span class="text_12"> registry. That is precisely what happens under the covers when you enable Docker support in Visual Studio. Your Dockerfile will use an existing </span><span class="text_13">aspnetcore</span><span class="text_12"> image.</span></p>
	<p class="block_27"><span class="text_8">Earlier we explained which Docker images and repos you can use, depending on the framework and OS you have chosen. For instance, if you want to use ASP.NET Core (Linux or Windows), the image to use is </span><span class="text_9">microsoft/dotnet:2.2-aspnetcore-runtime</span><span class="text_8">. Therefore, you just need to specify what base Docker image you will use for your container. You do that by adding </span><span class="text_9">FROM microsoft/dotnet:2.2-aspnetcore-runtime</span><span class="text_8"> to your Dockerfile. This will be automatically performed by Visual Studio, but if you were to update the version, you update this value.</span></p>
	<p class="block_14">Using an official .NET image repository from Docker Hub with a version number ensures that the same language features are available on all machines (including development, testing, and production).</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.11.10_PM.png" alt="Image" class="calibre55"/>The following example shows a sample Dockerfile for an ASP.NET Core container.</p>
	<p class="block_15"><span class="text_12">In this case, the image is based on version 2.2 of the official ASP.NET Core Docker image (multi-arch for Linux and Windows). This is the setting </span><span class="text_13">FROM microsoft/dotnet:2.2-aspnetcore-runtime</span><span class="text_12">. (For more information about this base image, see the </span><a href="https://hub.docker.com/r/microsoft/dotnet/" class="text_14">.NET Core Docker Image</a><span class="text_12"> page.) In the Dockerfile, you also need to instruct Docker to listen on the TCP port you will use at runtime (in this case, port 80, as configured with the EXPOSE setting).</span></p>
	<p class="block_27"><span class="text_8">You can specify additional configuration settings in the Dockerfile, depending on the language and framework you’re using. For instance, the ENTRYPOINT line with </span><span class="text_9">[“dotnet”, “MySingleContainerWebApp.dll”]</span><span class="text_8"> tells Docker to run a .NET Core application. If you’re using the SDK and the .NET Core CLI (dotnet CLI) to build and run the .NET application, this setting would be different. The bottom line is that the ENTRYPOINT line and other settings will be different depending on the language and platform you choose for your application.</span></p>
	<h3 id="id_Toc534713617" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Building Docker Images for .NET Core Applications</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images" class="text_1">https://docs.microsoft.com/dotnet/core/docker/building-net-docker-images</a></li>
	<li class="block_20"><span class="text_2">Build your own image</span><span class="text_">. In the official Docker documentation.<br class="calibre6"/></span><a href="https://docs.docker.com/engine/tutorials/dockerimages/" class="text_1">https://docs.docker.com/engine/tutorials/dockerimages/</a></li>
	<li class="block_20"><span class="text_2">Staying up-to-date with .NET Container Images</span><span class="text_"><br class="calibre6"/></span><a href="https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/" class="text_1">https://blogs.msdn.microsoft.com/dotnet/2018/06/18/staying-up-to-date-with-net-container-images/</a></li>
	<li class="block_20"><span class="text_2">Using .NET and Docker Together - DockerCon 2018 Update</span><span class="text_"><br class="calibre6"/></span><a href="https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/" class="text_1">https://blogs.msdn.microsoft.com/dotnet/2018/06/13/using-net-and-docker-together-dockercon-2018-update/</a></li>
</ul>
	<h3 id="id_Toc534713618" class="block_19">Using multi-arch image repositories</h3>
	<p class="block_17"><span class="text_5">A single repo can contain platform variants, such as a Linux image and a Windows image. This feature allows vendors like Microsoft (base image creators) to create a single repo to cover multiple platforms (that is Linux and Windows). For example, the </span><a href="https://hub.docker.com/r/microsoft/aspnetcore/" class="text_4">microsoft/aspnetcore</a><span class="text_5"> repository available in the Docker Hub registry provides support for Linux and Windows Nano Server by using the same repo name.</span></p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.13.36_PM.png" alt="Image" class="calibre56"/>If you specify a tag, targeting a platform that is explicit like in the following cases: </p>
	<p class="block_27"><span class="text_8"><img src="images/Screen_Shot_2019-01-15_at_6.13.43_PM.png" alt="Image" class="calibre57"/>But, if you specify the same image name, even with the same tag, the multi-arch images (like the </span><span class="text_9">aspnetcore</span><span class="text_8"> image) will use the Linux or Windows version depending on the Docker host OS you’re deploying, as shown in the following example:</span></p>
	<p class="block_14">This way, when you pull an image from a Windows host, it will pull the Windows variant, and pulling the same image name from a Linux host will pull the Linux variant.</p>
	<h3 id="id_Toc534713619" class="block_19">Multi-stage builds in Dockerfile</h3>
	<p class="block_14">The Dockerfile is similar to a batch script. Similar to what you would do if you had to set up the machine from the command line.</p>
	<p class="block_14">It starts with a base image that sets up the initial context, it’s like the startup filesystem, that sits on top of the host OS. It’s not an OS, but you can think of if like “the” OS inside the container.</p>
	<p class="block_14">The execution of every command line creates a new layer on the filesystem with the changes from the previous one, so that, when combined, produce the resulting filesystem.</p>
	<p class="block_14">Since every new layer “rests” on top of the previous one and the resulting image size increases with every command, images can get very large if they have to include, for example, the SDK needed to build and publish an application.</p>
	<p class="block_14">This is where multi-stage builds get into the plot (from Docker 17.05 and higher) to do their magic.</p>
	<p class="block_14">The core idea is that you can separate the Dockerfile execution process in stages, where a stage is an initial image followed by one or more commands, and the last stage determines the final image size.</p>
	<p class="block_14">In short, multi-stage builds allow splitting the creation in different “phases” and then assemble the final image taking only the relevant directories from the intermediate stages. The general strategy to use this feature is:</p>
	<ol class="list_1">
	<li class="block_25">Use a base SDK image (doesn’t matter how large), with everything needed to build and publish the application to a folder and then</li>
	<li class="block_25">Use a base, small, runtime-only image and copy the publishing folder from the previous stage to produce a small final image.</li>
</ol>
	<p class="block_14">Probably the best way to understand multi-stage is going through a Dockerfile in detail, line by line, so let’s begin with the initial Dockerfile created by Visual Studio when adding Docker support to a project and will get into some optimizations later.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.14.31_PM.png" alt="Image" class="calibre58"/>The initial Dockerfile might look something like this:</p>
	<p class="block_14">And these are the details, line by line:</p>
	<ul class="list_">
	<li class="block_25"><b class="calibre1">Line #1:</b> Begin a stage with a “small” runtime-only base image, call it <b class="calibre1">base</b> for reference.</li>
	<li id="id_Hlk530412696" class="block_25"><b class="calibre1">Line #2:</b> Create <b class="calibre1">/app</b> directory in the image.</li>
	<li class="block_25"><b class="calibre1">Line #3:</b> Expose port <b class="calibre1">80</b>. </li>
	<li class="block_25"><b class="calibre1">Line #5:</b> Begin a new stage with “large” image for building/publishing, call it <b class="calibre1">build</b> for reference.</li>
	<li class="block_25"><b class="calibre1">Line #6:</b> Create directory <b class="calibre1">/src</b> in the image.</li>
	<li class="block_25"><b class="calibre1">Line #7:</b> Up to line 16, copy referenced projects <b class="calibre1">.csproj</b> files, to be able to restore packages later. </li>
	<li class="block_25"><b class="calibre1">Line #17:</b> Restore packages for the <b class="calibre1">Catalog.API</b> project and the referenced projects.</li>
	<li class="block_25"><b class="calibre1">Line #18:</b> Copy <b class="calibre1">all directory tree for the solution</b> (except the files/directories included in the <b class="calibre1">.dockerignore</b> file) from to the <b class="calibre1">/src</b> directory in the image.</li>
	<li class="block_25"><b class="calibre1">Line #19:</b> Change current folder to <b class="calibre1">Catalog.API</b> project.</li>
	<li class="block_25"><b class="calibre1">Line #20:</b> Build project (and other project dependencies) and output to <b class="calibre1">/app</b> directory in the image. </li>
	<li class="block_25"><b class="calibre1">Line #22:</b> Begin a new stage continuing from build, call it <b class="calibre1">publish</b> for reference.</li>
	<li class="block_25"><b class="calibre1">Line #23:</b> Publish project (and dependencies) and output to <b class="calibre1">/app</b> directory in the image. </li>
	<li class="block_25"><b class="calibre1">Line #25:</b> Begin a new stage continuing from <b class="calibre1">base</b> and call it <b class="calibre1">final</b></li>
	<li class="block_25"><b class="calibre1">Line #26:</b> Change current directory to <b class="calibre1">/app</b></li>
	<li class="block_25"><b class="calibre1">Line #27:</b> Copy the <b class="calibre1">/app</b> directory from stage <b class="calibre1">publish</b> to the current directory</li>
	<li class="block_25"><b class="calibre1">Line #28:</b> Define the command to run when the container is started.</li>
</ul>
	<p class="block_14">Now let’s explore some optimizations to improve the whole process performance that, in the case of eShopOnContainers, means about 22 minutes or more to build the complete solution in Linux containers.</p>
	<p class="block_14">You’ll take advantage of Docker’s layer cache feature, which is quite simple: if the base image and the commands are the same as some previously executed, it can just use the resulting layer without the need to execute the commands, thus saving some time.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.15.04_PM.png" alt="Image" class="calibre59"/>So, let’s focus on the <b class="calibre5">build</b> stage, lines 5-6 are mostly the same, but lines 7-17 are different for every service from eShopOnContainers, so they have to execute every single time, however if you changed lines 7-16 to:</p>
	<p class="block_14">Then it would be just the same for every service, it would copy the whole solution and would create a larger layer but:</p>
	<div class="calibre60">
	<div class="block_30">1) The copy process would only be executed the first time (and when rebuilding if a file is changed) and would use the cache for all other services and</div>
	<div class="block_30">2) Since the larger image occurs in an intermediate stage it, doesn’t affect the final image size.</div>
</div>
	<p class="block_27"><span class="text_8"><img src="images/Screen_Shot_2019-01-15_at_6.15.13_PM.png" alt="Image" class="calibre61"/>The next significant optimization involves the </span><span class="text_9">restore</span><span class="text_8"> command executed in line 17, which is also different for every service of eShopOnContainers. If you change that line to just:</span></p>
	<p class="block_14">It would restore the packages for the whole solution, but then again, it would do it just once, instead of the 15 times with the current strategy.</p>
	<p class="block_27"><span class="text_8">However, </span><span class="text_9">dotnet restore</span><span class="text_8"> only runs if there’s a single project or solution file in the folder, so achieving this is a bit more complicated and the way to solve it, without getting into too many details, is this:</span></p>
	<div class="calibre60">
	<div class="block_30">1) Add the following lines to <b class="calibre1">.dockerignore</b>:</div>
</div>
	<div class="calibre62">
	<div class="block_31">– <span class="text_15">*.sln</span><span class="text_16">, to ignore all solution files in the main folder tree</span></div>
	<div class="block_31">– <span class="text_15">!eShopOnContainers-ServicesAndWebApps.sln</span><span class="text_16">, to include only this solution file.</span></div>
</div>
	<div class="calibre60">
	<div class="block_31">2) <span class="text_16">Include the </span><span class="text_15">/ignoreprojectextensions:.dcproj</span><span class="text_16"> argument to </span><span class="text_15">dotnet restore</span><span class="text_16">, so it also ignores the docker-compose project and only restores the packages for the eShopOnContainers-ServicesAndWebApps solution.</span></div>
</div>
	<p class="block_14">For the final optimization, it just happens that line 20 is redundant, as line 23 also builds the application and comes, in essence, right after line 20, so there goes another time-consuming command.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.16.04_PM.png" alt="Image" class="calibre63"/>The resulting file is then:</p>
	<h3 id="id_Toc534713620" class="block_19">Creating your base image from scratch</h3>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.16.36_PM.png" alt="Image" class="calibre64"/>You can create your own Docker base image from scratch. This scenario is not recommended for someone who is starting with Docker, but if you want to set the specific bits of your own base image, you can do so.</p>
	<h3 id="id_Toc534713621" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Multi-arch .NET Core images</span><span class="text_">.<br class="calibre6"/></span><a href="https://github.com/dotnet/announcements/issues/14" class="text_1">https://github.com/dotnet/announcements/issues/14</a></li>
	<li class="block_20"><span class="text_2">Create a base image</span><span class="text_">. Official Docker documentation.<br class="calibre6"/></span><a href="https://docs.docker.com/engine/userguide/eng-image/baseimages/" class="text_1">https://docs.docker.com/engine/userguide/eng-image/baseimages/</a></li>
</ul>
	<p class="block_14">For each service in your application, you need to create a related image. If your application is made up of a single service or web application, you just need a single image.</p>
	<p class="block_14">Note that the Docker images are built automatically for you in Visual Studio. The following steps are only needed for the editor/CLI workflow and explained for clarity about what happens underneath.</p>
	<p class="block_14">You, as developer, need to develop and test locally until you push a completed feature or change to your source control system (for example, to GitHub). This means that you need to create the Docker images and deploy containers to a local Docker host (Windows or Linux VM) and run, test, and debug against those local containers.</p>
	<p class="block_14">To create a custom image in your local environment by using Docker CLI and your Dockerfile, you can use the docker build command, as in Figure 5-5.</p>
	<p class="block_14"><img src="images/image-43.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image8.png" class="calibre65"/></p>
	<p class="block_23"><span class="text_6">Figure 5-5</span><i class="calibre8">. Creating a custom Docker image</i></p>
	<p class="block_27"><span class="text_8">Optionally, instead of directly running docker build from the project folder, you can first generate a deployable folder with the required .NET libraries and binaries by running </span><span class="text_9">dotnet publish</span><span class="text_8">, and then use the </span><span class="text_9">docker build</span><span class="text_8"> command.</span></p>
	<p class="block_27"><span class="text_8">This will create a Docker image with the name </span><span class="text_9">cesardl/netcore-webapi-microservice-docker:first</span><span class="text_8">. In this case, :first is a tag representing a specific version. You can repeat this step for each custom image you need to create for your composed Docker application.</span></p>
	<p class="block_27"><span class="text_8">When an application is made of multiple containers (that is, it is a multi-container application), you can also use the </span><span class="text_9">docker-compose up –build</span><span class="text_8"> command to build all the related images with a single command by using the metadata exposed in the related docker-compose.yml files.</span></p>
	<p class="block_14">You can find the existing images in your local repository by using the docker images command, as shown in Figure 5-6.</p>
	<p class="block_14"><img src="images/image-44.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image9.png" class="calibre66"/></p>
	<p class="block_23"><span class="text_6">Figure 5-6.</span><i class="calibre8"> Viewing existing images using the docker images command</i></p>
	<h3 id="id_Toc534713623" class="block_19">Creating Docker images with Visual Studio</h3>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.17.17_PM.png" alt="Image" class="calibre67"/>When you use Visual Studio to create a project with Docker support, you don’t explicitly create an image. Instead, the image is created for you when you press <b class="calibre5">F5</b> (or <b class="calibre5">Ctrl-F5</b>) to run the dockerized application or service. This step is automatic in Visual Studio and you won’t see it happen, but it’s important that you know what’s going on underneath.</p>
	<p class="block_17"><span class="text_5">The </span><a href="https://docs.docker.com/compose/compose-file/" class="text_4">docker-compose.yml</a><span class="text_5"> file lets you define a set of related services to be deployed as a composed application with deployment commands. It also configures its dependency relations and run-time configuration.</span></p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.18.04_PM.png" alt="Image" class="calibre68"/>To use a docker-compose.yml file, you need to create the file in your main or root solution folder, with content similar to that in the following example:</p>
	<p class="block_14">This docker-compose.yml file is a simplified and merged version. It contains static configuration data for each container (like the name of the custom image), which is always required, and configuration information that might depend on the deployment environment, like the connection string. In later sections, you will learn how to split the docker-compose.yml configuration into multiple docker-compose files and override values depending on the environment and execution type (debug or release).</p>
	<p class="block_27"><span class="text_8">The docker-compose.yml file example defines four services: the </span><span class="text_9">webmvc</span><span class="text_8"> service (a web application), two microservices (</span><span class="text_9">ordering.api</span><span class="text_8"> and </span><span class="text_9">basket.api</span><span class="text_8">), and one data source container, </span><span class="text_9">sql.data</span><span class="text_8">, based on SQL Server for Linux running as a container. Each service will be deployed as a container, so a Docker image is required for each.</span></p>
	<p class="block_27"><span class="text_8">The docker-compose.yml file specifies not only what containers are being used, but how they are individually configured. For instance, the </span><span class="text_9">webmvc</span><span class="text_8"> container definition in the .yml file:</span></p>
	<ul class="list_">
	<li class="block_32"><span class="text_16">Uses a pre-built </span><span class="text_15">eshop/web:latest</span><span class="text_16"> image. However, you could also configure the image to be built as part of the docker-compose execution with an additional configuration based on a build: section in the docker-compose file.</span></li>
	<li class="block_25">Initializes two environment variables (CatalogUrl and OrderingUrl).</li>
	<li class="block_25">Forwards the exposed port 80 on the container to the external port 80 on the host machine.</li>
	<li class="block_25">Links the web app to the catalog and ordering service with the depends_on setting. This causes the service to wait until those services are started.</li>
</ul>
	<p class="block_14">We will revisit the docker-compose.yml file in a later section when we cover how to implement microservices and multi-container apps.</p>
	<h3 id="id_Toc534713625" class="block_19">Working with docker-compose.yml in Visual Studio 2017</h3>
	<p class="block_14">Besides adding a Dockerfile to a project, as we mentioned before, Visual Studio 2017 (from 15.8 on) can add orchestrator support for Docker Compose to a solution.</p>
	<p class="block_27"><span class="text_8">When you add container orchestrator support, as shown in Figure 5-7, for the first time, Visual Studio creates the Dockerfile for the project and creates a new (service section) project in your solution with several global </span><span class="text_9">docker-compose*.yml</span><span class="text_8"> files, and then adds the project to those files. You can then open the docker-compose.yml files and update them with additional features.</span></p>
	<p class="block_14">You have to repeat this operation form every project you want to include in the docker-compose.yml file.</p>
	<p class="block_14">At the time of this writing, Visual Studio supports Docker Compose and Service Fabric orchestrators.</p>
	<p class="block_14"><img src="images/image-45.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image21.png" class="calibre69"/></p>
	<p class="block_23"><span class="text_6">Figure 5-7</span><i class="calibre8">. Adding Docker support in Visual Studio 2017 by right-clicking an ASP.NET Core project</i></p>
	<p class="block_27"><span class="text_8">After you add orchestrator support to your solution in Visual Studio, you will also see a new node (in the </span><span class="text_9">docker-compose.dcproj</span><span class="text_8"> project file) in Solution Explorer that contains the added docker-compose.yml files, as shown in Figure 5-8.</span></p>
	<p class="block_14"><img src="images/image-46.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image11.png" class="calibre70"/></p>
	<p class="block_23"><span class="text_6">Figure 5-8</span><i class="calibre8">. The </i><span class="text_6">docker-compose</span><i class="calibre8"> tree node added in Visual Studio 2017 Solution Explorer</i></p>
	<p class="block_27"><span class="text_8"><img src="images/Screen_Shot_2019-01-15_at_6.18.42_PM.png" alt="Image" class="calibre64"/>You could deploy a multi-container application with a single docker-compose.yml file by using the </span><span class="text_9">docker-compose up</span><span class="text_8"> command. However, Visual Studio adds a group of them so you can override values depending on the environment (development or production) and execution type (release or debug). This capability will be explained in later sections.</span></p>
	<p class="block_14">If your application only has a single container, you can run it by deploying it to your Docker host (VM or physical server). However, if your application contains multiple services, you can deploy it as a composed application, either using a single CLI command (docker-compose up), or with Visual Studio, which will use that command under the covers. Let’s look at the different options.</p>
	<h3 id="id_Toc534713627" class="block_19">Option A: Running a single-container application</h3>
	<h4 id="id_usingdockercli" class="block_33">Using Docker CLI</h4>
	<p class="block_27"><span class="text_8"><img src="images/Screen_Shot_2019-01-15_at_6.19.23_PM.png" alt="Image" class="calibre59"/>You can run a Docker container using the </span><span class="text_9">docker run</span><span class="text_8"> command, as shown in Figure 5-9:</span></p>
	<p class="block_27"><span class="text_8">The above command will create a new container instance from the specified image, every time it’s run. You can use the </span><span class="text_9">–name</span><span class="text_8"> parameter to give a name to the container and then use </span><span class="text_9">docker start {name}</span><span class="text_8"> (or use the container id or automatic name) to run an existing container instance.</span></p>
	<p class="block_14"><img src="images/image-47.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image13.png" class="calibre71"/></p>
	<p class="block_23"><span class="text_6">Figure 5-9</span><i class="calibre8">. Running a Docker container using the docker run command</i></p>
	<p class="block_14">In this case, the command binds the internal port 5000 of the container to port 80 of the host machine. This means that the host is listening on port 80 and forwarding to port 5000 on the container.</p>
	<p class="block_27"><span class="text_8">The hash shown is the container id and it’s also assigned a random readable name if the </span><span class="text_9">–name</span><span class="text_8"> option is not used.</span></p>
	<h4 id="id_usingvisualstudio" class="block_33">Using Visual Studio</h4>
	<p class="block_14">If you haven’t added container orchestrator support, you can also run a single container app in Visual Studio by pressing <b class="calibre5">Ctrl-F5</b> and you can also use <b class="calibre5">F5</b> to debug the application within the container. The container runs locally using docker run.</p>
	<h3 id="id_Toc534713628" class="block_19">Option B: Running a multi-container application</h3>
	<p class="block_14">In most enterprise scenarios, a Docker application will be composed of multiple services, which means you need to run a multi-container application, as shown in Figure 5-10.</p>
	<p class="block_14"><img src="images/image-48.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image14.png" class="calibre72"/></p>
	<p class="block_23"><span class="text_6">Figure 5-10</span><i class="calibre8">. VM with Docker containers deployed</i></p>
	<h4 id="id_usingdockercli1" class="block_33">Using Docker CLI</h4>
	<p class="block_27"><span class="text_8">To run a multi-container application with the Docker CLI, you use the </span><span class="text_9">docker-compose up</span><span class="text_8"> command. This command uses the </span><span class="text_17">docker-compose.yml</span><span class="text_8"> file that you have at the solution level to deploy a multi-container application. Figure 5-11 shows the results when running the command from your main solution directory, which contains the docker-compose.yml file.</span></p>
	<p class="block_14"><img src="images/image-49.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image15.png" class="calibre73"/></p>
	<p class="block_23"><span class="text_6">Figure 5-11</span><i class="calibre8">. Example results when running the docker-compose up command</i></p>
	<p class="block_14">After the docker-compose up command runs, the application and its related containers are deployed into your Docker host, as depicted in Figure 5-10.</p>
	<h4 id="id_usingvisualstudio1" class="block_33">Using Visual Studio</h4>
	<p class="block_14">Running a multi-container application using Visual Studio 2017 can’t get any simpler. You just press <b class="calibre5">Ctrl-F5</b> to run or <b class="calibre5">F5</b> to debug, as usual, setting up the <b class="calibre5">docker-compose</b> project as the startup project. Visual Studio handles all needed setup, so you can create breakpoints as usual and debug what finally become independent processes running in “remote servers”, just like that.</p>
	<p class="block_14">As mentioned before, each time you add Docker solution support to a project within a solution, that project is configured in the global (solution-level) docker-compose.yml file, which lets you run or debug the whole solution at once. Visual Studio will start one container for each project that has Docker solution support enabled, and perform all the internal steps for you (dotnet publish, docker build, etc.).</p>
	<p class="block_14">If you want to take a peek at all the drudgery, take a look at the file:</p>
	<p class="block_34">{root solution folder}-compose.vs.debug.g.yml</p>
	<p class="block_14">The important point here is that, as shown in Figure 5-12, in Visual Studio 2017 there is an additional <b class="calibre5">Docker</b> command for the F5 key action. This option lets you run or debug a multi-container application by running all the containers that are defined in the docker-compose.yml files at the solution level. The ability to debug multiple-container solutions means that you can set several breakpoints, each breakpoint in a different project (container), and while debugging from Visual Studio you will stop at breakpoints defined in different projects and running on different containers.</p>
	<p class="block_14"><img src="images/image-50.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image16.png" class="calibre74"/></p>
	<p class="block_23"><span class="text_6">Figure 5-12</span><i class="calibre8">. Running multi-container apps in Visual Studio 2017</i></p>
	<h3 id="id_Toc534713629" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Deploy an ASP.NET container to a remote Docker host</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker" class="text_1">https://docs.microsoft.com/azure/vs-azure-tools-docker-hosting-web-apps-in-docker</a></li>
</ul>
	<h3 id="id_Toc534713630" class="block_19">A note about testing and deploying with orchestrators</h3>
	<p class="block_17"><span class="text_5"><img src="images/Screen_Shot_2019-01-15_at_6.19.59_PM.png" alt="Image" class="calibre75"/>The docker-compose up and docker run commands (or running and debugging the containers in Visual Studio) are adequate for testing containers in your development environment. But you should not use this approach for production deployments, where you should target orchestrators like </span><a href="https://kubernetes.io/" class="text_4">Kubernetes</a><span class="text_5"> or </span><a href="https://azure.microsoft.com/services/service-fabric/" class="text_4">Service Fabric</a><span class="text_5">. If you’re using Kubernetes you have to use </span><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" class="text_4">pods</a><span class="text_5"> to organize containers and </span><a href="https://kubernetes.io/docs/concepts/services-networking/service/" class="text_4">services</a><span class="text_5"> to network them. You also use </span><a href="https://kubernetes.io/docs/tutorials/k8s201/" class="text_4">deployments</a><span class="text_5"> to organize pod creation and modification.</span></p>
	<p class="block_14">This step will vary depending on what your application is doing. In a simple .NET Core Web application that is deployed as a single container or service, you can access the service by opening a browser on the Docker host and navigating to that site, as shown in Figure 5-13. (If the configuration in the Dockerfile maps the container to a port on the host that is anything other than 80, include the host port in the URL.)</p>
	<p class="block_14"><img src="images/image-51.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image18.png" class="calibre76"/></p>
	<p class="block_23"><span class="text_6">Figure 5-13</span><i class="calibre8">. Example of testing your Docker application locally using localhost</i></p>
	<p class="block_14">If localhost is not pointing to the Docker host IP (by default, when using Docker CE, it should), to navigate to your service, use the IP address of your machine’s network card.</p>
	<p class="block_14">Note that this URL in the browser uses port 80 for the particular container example being discussed. However, internally the requests are being redirected to port 5000, because that was how it was deployed with the docker run command, as explained in a previous step.</p>
	<p class="block_14">You can also test the application using curl from the terminal, as shown in Figure 5-14. In a Docker installation on Windows, the default Docker Host IP is always 10.0.75.1 in addition to your machine’s actual IP address.</p>
	<p class="block_14"><img src="images/image-52.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image19.png" class="calibre77"/></p>
	<p class="block_23"><span class="text_6">Figure 5-14</span><i class="calibre8">. Example of testing your Docker application locally using curl</i></p>
	<h3 id="id_Toc534713632" class="block_19">Testing and debugging containers with Visual Studio 2017</h3>
	<p class="block_14">When running and debugging the containers with Visual Studio 2017, you can debug the .NET application in much the same way as you would when running without containers.</p>
	<h3 id="id_Toc534713633" class="block_19">Testing and debugging without Visual Studio</h3>
	<p class="block_14">If you’re developing using the editor/CLI approach, debugging containers is more difficult and you will want to debug by generating traces.</p>
	<h3 id="id_Toc534713634" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Debugging apps in a local Docker container</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/vs-azure-tools-docker-edit-and-refresh" class="text_1">https://docs.microsoft.com/azure/vs-azure-tools-docker-edit-and-refresh</a></li>
	<li class="block_20"><span class="text_2">Steve Lasker. Build, Debug, Deploy ASP.NET Core Apps with Docker.</span><span class="text_"> Video.<br class="calibre6"/></span><a href="https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115" class="text_1">https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T115</a></li>
</ul>
	<h2 id="id_Toc534713635" class="block_18">Simplified workflow when developing containers with Visual Studio</h2>
	<p class="block_14">Effectively, the workflow when using Visual Studio is a lot simpler than if you use the editor/CLI approach. Most of the steps required by Docker related to the Dockerfile and docker-compose.yml files are hidden or simplified by Visual Studio, as shown in Figure 5-15.</p>
	<p class="block_14"><img src="images/image-53.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\docker-application-development-process\media\image20.png" class="calibre78"/></p>
	<p class="block_23"><span class="text_6">Figure 5-15</span><i class="calibre8">. Simplified workflow when developing with Visual Studio</i></p>
	<p class="block_14">In addition, you need to perform step 2 (adding Docker support to your projects) just once. Therefore, the workflow is similar to your usual development tasks when using .NET for any other development. You need to know what is going on under the covers (the image build process, what base images you’re using, deployment of containers, etc.) and sometimes you will also need to edit the Dockerfile or docker-compose.yml file to customize behaviors. But most of the work is greatly simplified by using Visual Studio, making you a lot more productive.</p>
	<h3 id="id_Toc534713636" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Steve Lasker. .NET Docker Development with Visual Studio 2017</span><span class="text_"><br class="calibre6"/></span><a href="https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111" class="text_1">https://channel9.msdn.com/Events/Visual-Studio/Visual-Studio-2017-Launch/T111</a></li>
</ul>
	<h2 id="id_Toc534713637" class="block_18">Using PowerShell commands in a Dockerfile to set up Windows Containers</h2>
	<p class="block_17"><span class="text_4"><img src="images/Screen_Shot_2019-01-15_at_6.20.32_PM.png" alt="Image" class="calibre79"/></span><a href="https://docs.microsoft.com/virtualization/windowscontainers/about/index" class="text_4">Windows Containers</a><span class="text_5"> allow you to convert your existing Windows applications into Docker images and deploy them with the same tools as the rest of the Docker ecosystem. To use Windows Containers, you run PowerShell commands in the Dockerfile, as shown in the following example:</span></p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_6.20.58_PM.png" alt="Image" class="calibre59"/>In this case, we are using a Windows Server Core base image (the FROM setting) and installing IIS with a PowerShell command (the RUN setting). In a similar way, you could also use PowerShell commands to set up additional components like ASP.NET 4.x, .NET 4.6, or any other Windows software. For example, the following command in a Dockerfile sets up ASP.NET 4.5:</p>
	<h3 id="id_Toc534713638" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">aspnet-docker/Dockerfile.</span><span class="text_"> Example PowerShell commands to run from dockerfiles to include Windows features.<br class="calibre6"/></span><a href="https://github.com/Microsoft/aspnet-docker/blob/master/4.7.1-windowsservercore-ltsc2016/runtime/Dockerfile" class="text_1">https://github.com/Microsoft/aspnet-docker/blob/master/4.7.1-windowsservercore-ltsc2016/runtime/Dockerfile</a></li>
</ul>
	<p class="block_15"> </p>
	</body></html>
