<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_21" id="calibre_pb_10"> </p>
	<p id="id_Toc534713716" class="block_22">Tackle Business Complexity in a Microservice with DDD and CQRS Patterns</p>
	<p class="block_26">Design a domain model for each microservice or Bounded Context that reflects understanding of the business domain.</p>
	<p class="block_14">This section focuses on more advanced microservices that you implement when you need to tackle complex subsystems, or microservices derived from the knowledge of domain experts with ever-changing business rules. The architecture patterns used in this section are based on domain-driven design (DDD) and Command and Query Responsibility Segregation (CQRS) approaches, as illustrated in Figure 7-1.</p>
	<p class="block_14"><img src="images/image-90.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image1.png" class="calibre25"/></p>
	<p class="block_23"><span class="text_6">Figure 7-1</span><i class="calibre8">. External microservice architecture versus internal architecture patterns for each microservice</i></p>
	<p class="block_14">However, most of the techniques for data driven microservices, such as how to implement an ASP.NET Core Web API service or how to expose Swagger metadata with Swashbuckle or NSwag, are also applicable to the more advanced microservices implemented internally with DDD patterns. This section is an extension of the previous sections, because most of the practices explained earlier also apply here or for any kind of microservice.</p>
	<p class="block_14">This section first provides details on the simplified CQRS patterns used in the eShopOnContainers reference application. Later, you will get an overview of the DDD techniques that enable you to find common patterns that you can reuse in your applications.</p>
	<p class="block_17"><span class="text_5">DDD is a large topic with a rich set of resources for learning. You can start with books like </span><a href="https://domainlanguage.com/ddd/" class="text_4">Domain-Driven Design</a><span class="text_5"> by Eric Evans and additional materials from Vaughn Vernon, Jimmy Nilsson, Greg Young, Udi Dahan, Jimmy Bogard, and many other DDD/CQRS experts. But most of all you need to try to learn how to apply DDD techniques from the conversations, whiteboarding, and domain modeling sessions with the experts in your concrete business domain.</span></p>
	<h4 class="block_33">Additional resources</h4>
	<h5 id="id_ddddomaindrivendesign" class="block_35">DDD (Domain-Driven Design)</h5>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Eric Evans. Domain Language</span><span class="text_"><br class="calibre6"/></span><a href="https://domainlanguage.com/" class="text_1">https://domainlanguage.com/</a></li>
	<li class="block_20"><span class="text_2">Martin Fowler. Domain-Driven Design</span><span class="text_"><br class="calibre6"/></span><a href="https://martinfowler.com/tags/domain%20driven%20design.html" class="text_1">https://martinfowler.com/tags/domain%20driven%20design.html</a></li>
	<li class="block_20"><span class="text_2">Jimmy Bogard. Strengthening your domain: a primer</span><span class="text_"><br class="calibre6"/></span><a href="https://lostechies.com/jimmybogard/2010/02/04/strengthening-your-domain-a-primer/" class="text_1">https://lostechies.com/jimmybogard/2010/02/04/strengthening-your-domain-a-primer/</a></li>
</ul>
	<h5 id="id_dddbooks" class="block_35">DDD books</h5>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/" class="text_1">https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/</a></li>
	<li class="block_20"><span class="text_2">Eric Evans. Domain-Driven Design Reference: Definitions and Pattern Summaries</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-2014-09-22/dp/B01N8YB4ZO/" class="text_1">https://www.amazon.com/Domain-Driven-Design-Reference-Definitions-2014-09-22/dp/B01N8YB4ZO/</a></li>
	<li class="block_20"><span class="text_2">Vaughn Vernon. Implementing Domain-Driven Design</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/" class="text_1">https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/</a></li>
	<li class="block_20"><span class="text_2">Vaughn Vernon. Domain-Driven Design Distilled</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420/" class="text_1">https://www.amazon.com/Domain-Driven-Design-Distilled-Vaughn-Vernon/dp/0134434420/</a></li>
	<li class="block_20"><span class="text_2">Jimmy Nilsson. Applying Domain-Driven Design and Patterns</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202/" class="text_1">https://www.amazon.com/Applying-Domain-Driven-Design-Patterns-Examples/dp/0321268202/</a></li>
	<li class="block_20"><span class="text_2">Cesar de la Torre. N-Layered Domain-Oriented Architecture Guide with .NET</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/N-Layered-Domain-Oriented-Architecture-Guide-NET/dp/8493903612/" class="text_1">https://www.amazon.com/N-Layered-Domain-Oriented-Architecture-Guide-NET/dp/8493903612/</a></li>
	<li class="block_20"><span class="text_2">Abel Avram and Floyd Marinescu. Domain-Driven Design Quickly</span><span class="text_"><br class="calibre6"/></span><a href="https://www.amazon.com/Domain-Driven-Design-Quickly-Abel-Avram/dp/1411609255/" class="text_1">https://www.amazon.com/Domain-Driven-Design-Quickly-Abel-Avram/dp/1411609255/</a></li>
	<li class="block_20"><span class="text_2">Scott Millett, Nick Tune - Patterns, Principles, and Practices of Domain-Driven Design</span><span class="text_"><br class="calibre6"/></span><a href="http://www.wrox.com/WileyCDA/WroxTitle/Patterns-Principles-and-Practices-of-Domain-Driven-Design.productCd-1118714709.html" class="text_1">http://www.wrox.com/WileyCDA/WroxTitle/Patterns-Principles-and-Practices-of-Domain-Driven-Design.productCd-1118714709.html</a></li>
</ul>
	<h5 id="id_dddtraining" class="block_35">DDD training</h5>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Julie Lerman and Steve Smith. Domain-Driven Design Fundamentals</span><span class="text_"><br class="calibre6"/></span><a href="https://bit.ly/PS-DDD" class="text_1">https://bit.ly/PS-DDD</a></li>
</ul>
	<h1 id="id_Toc534713717" class="block_24">Apply simplified CQRS and DDD patterns in a microservice</h1>
	<p class="block_17"><span class="text_5">CQRS is an architectural pattern that separates the models for reading and writing data. The related term </span><a href="https://martinfowler.com/bliki/CommandQuerySeparation.html" class="text_4">Command Query Separation (CQS)</a><span class="text_5"> was originally defined by Bertrand Meyer in his book </span><span class="text_10">Object Oriented Software Construction</span><span class="text_5">. The basic idea is that you can divide a system’s operations into two sharply separated categories:</span></p>
	<ul class="list_">
	<li class="block_25">Queries. These return a result and do not change the state of the system, and they are free of side effects.</li>
	<li class="block_25">Commands. These change the state of a system.</li>
</ul>
	<p class="block_14">CQS is a simple concept—it is about methods within the same object being either queries or commands. Each method either returns state or mutates state, but not both. Even a single repository pattern object can comply with CQS. CQS can be considered a foundational principle for CQRS.</p>
	<p class="block_17"><a href="https://martinfowler.com/bliki/CQRS.html" class="text_4">Command and Query Responsibility Segregation (CQRS)</a><span class="text_5"> was introduced by Greg Young and strongly promoted by Udi Dahan and others. It is based on the CQS principle, although it is more detailed. It can be considered a pattern based on commands and events plus optionally on asynchronous messages. In many cases, CQRS is related to more advanced scenarios, like having a different physical database for reads (queries) than for writes (updates). Moreover, a more evolved CQRS system might implement </span><a href="http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/" class="text_4">Event-Sourcing (ES)</a><span class="text_5"> for your updates database, so you would only store events in the domain model instead of storing the current-state data. However, this is not the approach used in this guide; we are using the simplest CQRS approach, which consists of just separating the queries from the commands.</span></p>
	<p class="block_14">The separation aspect of CQRS is achieved by grouping query operations in one layer and commands in another layer. Each layer has its own data model (note that we say model, not necessarily a different database) and is built using its own combination of patterns and technologies. More importantly, the two layers can be within the same tier or microservice, as in the example (ordering microservice) used for this guide. Or they could be implemented on different microservices or processes so they can be optimized and scaled out separately without affecting one another.</p>
	<p class="block_14">CQRS means having two objects for a read/write operation where in other contexts there is one. There are reasons to have a denormalized reads database, which you can learn about in more advanced CQRS literature. But we are not using that approach here, where the goal is to have more flexibility in the queries instead of limiting the queries with constraints from DDD patterns like aggregates.</p>
	<p class="block_14">An example of this kind of service is the ordering microservice from the eShopOnContainers reference application. This service implements a microservice based on a simplified CQRS approach. It uses a single data source or database, but two logical models plus DDD patterns for the transactional domain, as shown in Figure 7-2.</p>
	<p class="block_14"><img src="images/image-91.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image2.png" class="calibre169"/></p>
	<p class="block_23"><span class="text_6">Figure 7-2</span><i class="calibre8">. Simplified CQRS- and DDD-based microservice</i></p>
	<p class="block_14">The application layer can be the Web API itself. The important design aspect here is that the microservice has split the queries and ViewModels (data models especially created for the client applications) from the commands, domain model, and transactions following the CQRS pattern. This approach keeps the queries independent from restrictions and constraints coming from DDD patterns that only make sense for transactions and updates, as explained in later sections.</p>
	<h1 id="id_Toc534713718" class="block_24">Apply CQRS and CQS approaches in a DDD microservice in eShopOnContainers</h1>
	<p class="block_14">The design of the ordering microservice at the eShopOnContainers reference application is based on CQRS principles. However, it uses the simplest approach, which is just separating the queries from the commands and using the same database for both actions.</p>
	<p class="block_14">The essence of those patterns, and the important point here, is that queries are idempotent: no matter how many times you query a system, the state of that system will not change. You could even use a different “reads” data model than the transactional logic “writes” domain model, although the ordering microservices is using the same database. Hence this is a simplified CQRS approach.</p>
	<p class="block_14">On the other hand, commands, which trigger transactions and data updates, change state in the system. With commands, you need to be careful when dealing with complexity and ever-changing business rules. This is the where you want to apply DDD techniques to have a better modeled system.</p>
	<p class="block_14">The DDD patterns presented in this guide should not be applied universally. They introduce constraints on your design. Those constraints provide benefits such as higher quality over time, especially in commands and other code that modifies system state. However, those constraints add complexity with fewer benefits for reading and querying data.</p>
	<p class="block_14">One such pattern is the Aggregate pattern, which we examine more in later sections. Briefly, in the Aggregate pattern, you treat many domain objects as a single unit as a result of their relationship in the domain. You might not always gain advantages from this pattern in queries; it can increase the complexity of query logic. For read-only queries, you do not get the advantages of treating multiple objects as a single Aggregate. You only get the complexity.</p>
	<p class="block_14">As shown in Figure 7-2, this guide suggests using DDD patterns only in the transactional/updates area of your microservice (that is, as triggered by commands). Queries can follow a simpler approach and should be separated from commands, following a CQRS approach.</p>
	<p class="block_14">For implementing the “queries side”, you can choose between many approaches, from your full-blown ORM like EF Core, AutoMapper projections, stored procedures, views, materialized views or a micro ORM.</p>
	<p class="block_17"><span class="text_5">In this guide and in eShopOnContainers (specifically the ordering microservice) we chose to implement straight queries using a micro ORM like </span><a href="https://github.com/StackExchange/dapper-dot-net" class="text_4">Dapper</a><span class="text_5">. This lets you implement any query based on SQL statements to get the best performance, thanks to a light framework with very little overhead.</span></p>
	<p class="block_14">Note that when you use this approach, any updates to your model that impact how entities are persisted to a SQL database also need separate updates to SQL queries used by Dapper or any other separate (non-EF) approaches to querying.</p>
	<h2 id="id_Toc534713719" class="block_18">CQRS and DDD patterns are not top-level architectures</h2>
	<p class="block_14">It’s important to understand that CQRS and most DDD patterns (like DDD layers or a domain model with aggregates) are not architectural styles, but only architecture patterns. Microservices, SOA, and event-driven architecture (EDA) are examples of architectural styles. They describe a system of many components, such as many microservices. CQRS and DDD patterns describe something inside a single system or component; in this case, something inside a microservice.</p>
	<p class="block_14">Different Bounded Contexts (BCs) will employ different patterns. They have different responsibilities, and that leads to different solutions. It is worth emphasizing that forcing the same pattern everywhere leads to failure. Do not use CQRS and DDD patterns everywhere. Many subsystems, BCs, or microservices are simpler and can be implemented more easily using simple CRUD services or using another approach.</p>
	<p class="block_14">There is only one application architecture: the architecture of the system or end-to-end application you are designing (for example, the microservices architecture). However, the design of each Bounded Context or microservice within that application reflects its own tradeoffs and internal design decisions at an architecture patterns level. Do not try to apply the same architectural patterns like CQRS or DDD everywhere.</p>
	<h4 class="block_33">Additional resources</h4>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Martin Fowler. CQRS</span><span class="text_"><br class="calibre6"/></span><a href="https://martinfowler.com/bliki/CQRS.html" class="text_1">https://martinfowler.com/bliki/CQRS.html</a></li>
	<li class="block_20"><span class="text_2">Greg Young. CQS vs. CQRS</span><span class="text_"><br class="calibre6"/></span><a href="http://codebetter.com/gregyoung/2009/08/13/command-query-separation/" class="text_1">http://codebetter.com/gregyoung/2009/08/13/command-query-separation/</a></li>
	<li class="block_20"><span class="text_2">Greg Young. CQRS Documents</span><span class="text_"><br class="calibre6"/></span><a href="https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf" class="text_1">https://cqrs.files.wordpress.com/2010/11/cqrs_documents.pdf</a></li>
	<li class="block_20"><span class="text_2">Greg Young. CQRS, Task Based UIs and Event Sourcing</span><span class="text_"><br class="calibre6"/></span><a href="http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/" class="text_1">http://codebetter.com/gregyoung/2010/02/16/cqrs-task-based-uis-event-sourcing-agh/</a></li>
	<li class="block_20"><span class="text_2">Udi Dahan. Clarified CQRS</span><span class="text_"><br class="calibre6"/></span><a href="http://udidahan.com/2009/12/09/clarified-cqrs/" class="text_1">http://udidahan.com/2009/12/09/clarified-cqrs/</a></li>
	<li class="block_20"><span class="text_2">CQRS</span><span class="text_"><br class="calibre6"/></span><a href="http://udidahan.com/2009/12/09/clarified-cqrs/" class="text_1">http://udidahan.com/2009/12/09/clarified-cqrs/</a></li>
	<li class="block_20"><span class="text_2">Event-Sourcing (ES)</span><span class="text_"><br class="calibre6"/></span><a href="http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/" class="text_1">http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/</a></li>
</ul>
	<h1 id="id_Toc534713720" class="block_24">Implement reads/queries in a CQRS microservice</h1>
	<p class="block_14">For reads/queries, the ordering microservice from the eShopOnContainers reference application implements the queries independently from the DDD model and transactional area. This was done primarily because the demands for queries and for transactions are drastically different. Writes execute transactions that must be compliant with the domain logic. Queries, on the other hand, are idempotent and can be segregated from the domain rules.</p>
	<p class="block_14">The approach is simple, as shown in Figure 7-3. The API interface is implemented by the Web API controllers using any infrastructure, such as a micro Object Relational Mapper (ORM) like Dapper, and returning dynamic ViewModels depending on the needs of the UI applications.</p>
	<p class="block_14"><img src="images/image-92.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image3.png" class="calibre170"/></p>
	<p class="block_23"><span class="text_6">Figure 7-3</span><i class="calibre8">. The simplest approach for queries in a CQRS microservice</i></p>
	<p class="block_14">This is the simplest possible approach for queries. The query definitions query the database and return a dynamic ViewModel built on the fly for each query. Since the queries are idempotent, they won’t change the data no matter how many times you run a query. Therefore, you don’t need to be restricted by any DDD pattern used in the transactional side, like aggregates and other patterns, and that is why queries are separated from the transactional area. You simply query the database for the data that the UI needs and return a dynamic ViewModel that does not need to be statically defined anywhere (no classes for the ViewModels) except in the SQL statements themselves.</p>
	<p class="block_17"><span class="text_5">Since this is a simple approach, the code required for the queries side (such as code using a micro ORM like </span><a href="https://github.com/StackExchange/Dapper" class="text_4">Dapper</a><span class="text_5">) can be implemented </span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.API/Application/Queries/OrderQueries.cs" class="text_4">within the same Web API project</a><span class="text_5">. Figure 7-4 shows this. The queries are defined in the </span><span class="text_7">Ordering.API</span><span class="text_5"> microservice project within the eShopOnContainers solution.</span></p>
	<p class="block_14"><img src="images/image-93.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image4.png" class="calibre171"/></p>
	<p class="block_23"><span class="text_6">Figure 7-4</span><i class="calibre8">. Queries in the Ordering microservice in eShopOnContainers</i></p>
	<h2 id="id_Toc534713721" class="block_18">Use ViewModels specifically made for client apps, independent from domain model constraints</h2>
	<p class="block_14">Since the queries are performed to obtain the data needed by the client applications, the returned type can be specifically made for the clients, based on the data returned by the queries. These models, or Data Transfer Objects (DTOs), are called ViewModels.</p>
	<p class="block_14">The returned data (ViewModel) can be the result of joining data from multiple entities or tables in the database, or even across multiple aggregates defined in the domain model for the transactional area. In this case, because you are creating queries independent of the domain model, the aggregates boundaries and constraints are completely ignored and you’re free to query any table and column you might need. This approach provides great flexibility and productivity for the developers creating or updating the queries.</p>
	<p class="block_14">The ViewModels can be static types defined in classes. Or they can be created dynamically based on the queries performed (as is implemented in the ordering microservice), which is very agile for developers.</p>
	<h2 id="id_Toc534713722" class="block_18">Use Dapper as a micro ORM to perform queries</h2>
	<p class="block_14">You can use any micro ORM, Entity Framework Core, or even plain ADO.NET for querying. In the sample application, Dapper was selected for the ordering microservice in eShopOnContainers as a good example of a popular micro ORM. It can run plain SQL queries with great performance, because it’s a very light framework. Using Dapper, you can write a SQL query that can access and join multiple tables.</p>
	<p class="block_17"><span class="text_5">Dapper is an open-source project (original created by Sam Saffron), and is part of the building blocks used in </span><a href="https://stackoverflow.com/" class="text_4">Stack Overflow</a><span class="text_5">. To use Dapper, you just need to install it through the </span><a href="https://www.nuget.org/packages/Dapper" class="text_4">Dapper NuGet package</a><span class="text_5">, as shown in the following figure:</span></p>
	<p class="block_14"><img src="images/image-94.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image4.1.png" class="calibre172"/></p>
	<p class="block_14">You also need to add a using statement so your code has access to the Dapper extension methods.</p>
	<p class="block_17"><span class="text_5">When you use Dapper in your code, you directly use the </span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection?view=netcore-2.1" class="text_4">SqlConnection</a><span class="text_5"> class available in the </span><a href="https://docs.microsoft.com/dotnet/api/system.data.sqlclient?view=netcore-2.1" class="text_4">System.Data.SqlClient</a><span class="text_5"> namespace. Through the QueryAsync method and other extension methods that extend the </span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.data.sqlclient.sqlconnection?view=netcore-2.1" class="text_4">SqlConnection</a><span class="text_5"> class, you can simply run queries in a straightforward and performant way.</span></p>
	<h2 id="id_Toc534713723" class="block_18">Dynamic versus static ViewModels</h2>
	<p class="block_14">When returning ViewModels from the server-side to client apps, you can think about those ViewModels as DTOs (Data Transfer Objects) that can be different to the internal domain entities of your entity model because the ViewModels hold the data the way the client app needs. Therefore, in many cases, you can aggregate data coming from multiple domain entities and compose the ViewModels precisely according to how the client app needs that data.</p>
	<p class="block_27"><span class="text_8">Those ViewModels or DTOs can be defined explicitly (as data holder classes) like the </span><span class="text_9">OrderSummary</span><span class="text_8"> class shown in a later code snippet, or you could just return dynamic ViewModels or dynamic DTOs simply based on the attributes returned by your queries, as a dynamic type.</span></p>
	<h3 id="id_Toc534713724" class="block_19">ViewModel as dynamic type</h3>
	<p class="block_27"><span class="text_8"><img src="images/image184.tiff" alt="Image" class="calibre173"/>As shown in the following code, a </span><span class="text_9">ViewModel</span><span class="text_8"> can be directly returned by the queries by just returning a </span><span class="text_21">dynamic</span><span class="text_8"> type that internally is based on the attributes returned by a query. That means that the subset of attributes to be returned is based on the query itself. Therefore, if you add a new column to the query or join, that data is dynamically added to the returned </span><span class="text_9">ViewModel</span><span class="text_8">. </span></p>
	<p class="block_14">The important point is that by using a dynamic type, the returned collection of data is dynamically assembled as the ViewModel.</p>
	<p class="block_14"><b class="calibre5">Pros:</b> This approach reduces the need to modify static ViewModel classes whenever you update the SQL sentence of a query, making this design approach pretty agile when coding, straightforward, and quick to evolve in regard to future changes.</p>
	<p class="block_14"><b class="calibre5">Cons:</b> In the long term, dynamic types can negatively impact the clarity and the compatibility of a service with client apps. In addition, middleware software like Swashbuckle cannot provide the same level of documentation on returned types if using dynamic types.</p>
	<h3 id="id_Toc534713725" class="block_19">ViewModel as predefined DTO classes</h3>
	<p class="block_14"><b class="calibre5">Pros</b>: Having static predefined ViewModel classes, like “contracts” based on explicit DTO classes, is definitely better for public APIs but also for long term microservices, even if they are only used by the same application.</p>
	<p class="block_14">If you want to specify response types for Swagger, you need to use explicit DTO classes as the return type. Therefore, predefined DTO classes allow you to offer richer information from Swagger. That improves the API documentation and compatibility when consuming an API.</p>
	<p class="block_14"><b class="calibre5">Cons</b>: As mentioned earlier, when updating the code, it takes some more steps to update the DTO classes.</p>
	<p class="block_14"><i class="calibre15">Tip based on our experience</i>: In the queries implemented at the Ordering microservice in eShopOnContainers, we started developing by using dynamic ViewModels as it was very straightforward and agile on the early development stages. But, once the development was stabilized, we chose to refactor the APIs and use static or pre-defined DTOs for the ViewModels, because it is clearer for the microservice’s consumers to know explicit DTO types, used as “contracts”.</p>
	<p class="block_14"><img src="images/image185.tiff" alt="Image" class="calibre174"/>In the following example, you can see how the query is returning data by using an explicit ViewModel DTO class: the OrderSummary class. </p>
	<h4 id="id_describeresponsetypesofwebapis" class="block_33">Describe response types of Web APIs</h4>
	<p class="block_14">Developers consuming web APIs and microservices are most concerned with what is returned — specifically response types and error codes (if not standard). These are handled in the XML comments and data annotations.</p>
	<p class="block_17"><span class="text_5"><img src="images/image186.tiff" alt="Image" class="calibre175"/>Without proper documentation in the Swagger UI, the consumer lacks knowledge of what types are being returned or what HTTP codes can be returned. That problem is fixed by adding the </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.mvc.producesresponsetypeattribute?view=aspnetcore-2.1" class="text_4">ProducesResponseTypeAttribute</a><span class="text_5">, so Swashbuckle can generate richer information about the API return model and values, as shown in the following code:</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image187.tiff" alt="Image" class="calibre176"/>However, the </span><span class="text_9">ProducesResponseType</span><span class="text_8"> attribute cannot use dynamic as a type but requires to use explicit types, like the </span><span class="text_9">OrderSummary</span><span class="text_8"> ViewModel DTO, shown in the following example:</span></p>
	<p class="block_27"><span class="text_8">This is another reason why explicit returned types are better than dynamic types, in the long term. When using the </span><span class="text_9">ProducesResponseType</span><span class="text_8"> attribute, you can also specify what is the expected outcome in regards possible HTTP errors/codes, like 200, 400, etc.</span></p>
	<p class="block_14">In the following image, you can see how Swagger UI shows the ResponseType information.</p>
	<p class="block_14"><img src="images/image-95.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image5.png" class="calibre177"/></p>
	<p class="block_23"><span class="text_6">Figure 7-5</span><i class="calibre8">. Swagger UI showing response types and possible HTTP status codes from a Web API</i></p>
	<p class="block_14">You can see in the image above some example values based on the ViewModel types plus the possible HTTP status codes that can be returned.</p>
	<h2 id="id_Toc534713726" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Dapper</span><span class="text_"><br class="calibre6"/></span><a href="https://github.com/StackExchange/dapper-dot-net" class="text_1">https://github.com/StackExchange/dapper-dot-net</a></li>
	<li class="block_20"><span class="text_2">Julie Lerman. Data Points - Dapper, Entity Framework and Hybrid Apps (MSDN Mag. article)</span><span class="text_"><br class="calibre6"/></span><a href="https://msdn.microsoft.com/magazine/mt703432.aspx" class="text_1">https://msdn.microsoft.com/magazine/mt703432.aspx</a></li>
	<li class="block_20"><span class="text_2">ASP.NET Core Web API Help Pages using Swagger</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio" class="text_1">https://docs.microsoft.com/aspnet/core/tutorials/web-api-help-pages-using-swagger?tabs=visual-studio</a></li>
</ul>
	<h1 id="id_Toc534713727" class="block_24">Design a DDD-oriented microservice</h1>
	<p class="block_17"><span class="text_5">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases. In the context of building applications, DDD talks about problems as domains. It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems. It also suggests many technical concepts and patterns, like domain entities with rich models (no </span><a href="https://martinfowler.com/bliki/AnemicDomainModel.html" class="text_4">anemic-domain model</a><span class="text_5">), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation. This section introduces the design and implementation of those internal patterns.</span></p>
	<p class="block_14">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches. But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language). In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules. Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</p>
	<p class="block_14">Where to draw the boundaries is the key task when designing and defining a microservice. DDD patterns help you understand the complexity in the domain. For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain. You build and refine a domain model that is contained within a boundary that defines your context. And that is very explicit in the form of a microservice. The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services. DDD is about boundaries and so are microservices.</p>
	<h2 id="id_Toc534713728" class="block_18">Keep the microservice context boundaries relatively small</h2>
	<p class="block_14">Determining where to place boundaries between Bounded Contexts balances two competing goals. First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion. Second, you want to avoid chatty communications between microservices. These goals can contradict one another. You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context. Cohesion is key within a single bounded context.</p>
	<p class="block_17"><span class="text_5">It is similar to the </span><a href="https://sourcemaking.com/refactoring/smells/inappropriate-intimacy" class="text_4">Inappropriate Intimacy code smell</a><span class="text_5"> when implementing classes. If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></p>
	<p class="block_14">Another way to look at this is autonomy. If a microservice must rely on another service to directly service a request, it is not truly autonomous.</p>
	<h2 id="id_Toc534713729" class="block_18">Layers in DDD microservices</h2>
	<p class="block_14">Most enterprise applications with significant business and technical complexity are defined by multiple layers. The layers are a logical artifact, and are not related to the deployment of the service. They exist to help developers manage the complexity in the code. Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</p>
	<p class="block_14">For example, an entity could be loaded from the database. Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API. The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</p>
	<p class="block_17"><span class="text_5">Additionally, you need to have always-valid entities (see the </span><a href="#id_Toc534713762" class="text_4">Designing validations in the domain model layer</a><span class="text_5"> section) controlled by aggregate roots (root entities). Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated. This is what the ViewModel is for. The ViewModel is a data model exclusively for presentation layer needs. The domain entities do not belong directly to the ViewModel. Instead, you need to translate between ViewModels and domain entities and vice versa.</span></p>
	<p class="block_14">When tackling complexity, it is important to have a domain model controlled by aggregate roots that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry-point or gate, the aggregate root.</p>
	<p class="block_14">Figure 7-5 shows how a layered design is implemented in the eShopOnContainers application.</p>
	<p class="block_14"><img src="images/image-96.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image6.png" class="calibre178"/></p>
	<p class="block_23"><span class="text_6">Figure 7-5</span><i class="calibre8">. DDD layers in the ordering microservice in eShopOnContainers</i></p>
	<p class="block_17"><span class="text_5">You want to design the system so that each layer communicates only with certain other layers. That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries. For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or </span><a href="https://en.wikipedia.org/wiki/Plain_Old_CLR_Object" class="text_4">POCO</a><span class="text_5">, classes). As shown in Figure 7-6, the </span><span class="text_7">Ordering.Domain</span><span class="text_5"> layer library has dependencies only on the .NET Core libraries or NuGet packages, but not on any other custom library, such as data library or persistence library.</span></p>
	<p class="block_14"><img src="images/image-97.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image7.png" class="calibre179"/></p>
	<p class="block_23"><span class="text_6">Figure 7-6</span><i class="calibre8">. Layers implemented as libraries allow better control of dependencies between layers</i></p>
	<h3 id="id_Toc534713730" class="block_19">The domain model layer</h3>
	<p class="block_17"><span class="text_5">Eric Evans’s excellent book </span><a href="https://domainlanguage.com/ddd/" class="text_4">Domain Driven Design</a><span class="text_5"> says the following about the domain model layer and the application layer.</span></p>
	<p class="block_37"><span class="text_22">Domain Model Layer</span><i class="calibre15">: Responsible for representing concepts of the business, information about the business situation, and business rules. State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure. This layer is the heart of business software.</i></p>
	<p class="block_14">The domain model layer is where the business is expressed. When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</p>
	<p class="block_17"><span class="text_5">Following the </span><a href="https://deviq.com/persistence-ignorance/" class="text_4">Persistence Ignorance</a><span class="text_5"> and the </span><a href="https://ayende.com/blog/3137/infrastructure-ignorance" class="text_4">Infrastructure Ignorance</a><span class="text_5"> principles, this layer must completely ignore data persistence details. These persistence tasks should be performed by the infrastructure layer. Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be </span><a href="https://en.wikipedia.org/wiki/Plain_Old_CLR_Object" class="text_4">POCO</a><span class="text_5">s.</span></p>
	<p class="block_14">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate. Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</p>
	<p class="block_14">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure. However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</p>
	<p class="block_14">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns. It is still very important to understand the physical data model and how it maps to your entity object model. Otherwise you can create impossible designs.</p>
	<p class="block_14">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database. In some entity models, the model might fit, but usually it does not. There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</p>
	<h3 id="id_Toc534713731" class="block_19">The application layer</h3>
	<p class="block_17"><span class="text_5">Moving on to the application layer, we can again cite Eric Evans’s book </span><a href="https://domainlanguage.com/ddd/" class="text_4">Domain Driven Design</a><span class="text_5">:</span></p>
	<p class="block_37"><span class="text_22">Application Layer:</span><i class="calibre15"> Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems. The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems. This layer is kept thin. It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</i></p>
	<p class="block_14">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project. The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps. It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events). The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library. The application layer must only coordinate tasks and must not hold or define any domain state (domain model). It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</p>
	<p class="block_14">Basically, the application logic is where you implement all use cases that depend on a given front end. For example, the implementation related to a Web API service.</p>
	<p class="block_14">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers. Most of all, the domain model layer must not directly depend on any infrastructure framework.</p>
	<h3 id="id_Toc534713732" class="block_19">The infrastructure layer</h3>
	<p class="block_14">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store. An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</p>
	<p class="block_17"><span class="text_5">In accordance with the previously mentioned </span><a href="https://deviq.com/persistence-ignorance/" class="text_4">Persistence Ignorance</a><span class="text_5"> and </span><a href="https://ayende.com/blog/3137/infrastructure-ignorance" class="text_4">Infrastructure Ignorance</a><span class="text_5"> principles, the infrastructure layer must not “contaminate” the domain model layer. You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks. Your domain model layer class library should have only your domain code, just </span><a href="https://en.wikipedia.org/wiki/Plain_Old_CLR_Object" class="text_4">POCO</a><span class="text_5"> entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></p>
	<p class="block_14">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 7-7.</p>
	<p class="block_14"><img src="images/image-98.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image8.png" class="calibre180"/></p>
	<p class="block_23"><span class="text_6">Figure 7-7</span><i class="calibre8">. Dependencies between layers in DDD</i></p>
	<p class="block_14">This layer design should be independent for each microservice. As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</p>
	<h4 class="block_33">Additional resources</h4>
	<ul class="list_">
	<li class="block_20"><span class="text_2">DevIQ. Persistence Ignorance principle</span><span class="text_"><br class="calibre6"/></span><a href="https://deviq.com/persistence-ignorance/" class="text_1">https://deviq.com/persistence-ignorance/</a></li>
	<li class="block_20"><span class="text_2">Oren Eini. Infrastructure Ignorance</span><span class="text_"><br class="calibre6"/></span><a href="https://ayende.com/blog/3137/infrastructure-ignorance" class="text_1">https://ayende.com/blog/3137/infrastructure-ignorance</a></li>
	<li class="block_20"><span class="text_2">Angel Lopez. Layered Architecture In Domain-Driven Design</span><span class="text_"><br class="calibre6"/></span><a href="https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/" class="text_1">https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/</a></li>
</ul>
	<h1 id="id_Toc534713733" class="block_24">Design a microservice domain model</h1>
	<p class="block_26">Define one rich domain model for each business microservice or Bounded Context. </p>
	<p class="block_14">Your goal is to create a single cohesive domain model for each business microservice or Bounded Context (BC). Keep in mind, however, that a BC or business microservice could sometimes be composed of several physical services that share a single domain model. The domain model must capture the rules, behavior, business language, and constraints of the single Bounded Context or business microservice that it represents.</p>
	<h2 id="id_Toc534713734" class="block_18">The Domain Entity pattern</h2>
	<p class="block_14">Entities represent domain objects and are primarily defined by their identity, continuity, and persistence over time, and not only by the attributes that comprise them. As Eric Evans says, “an object primarily defined by its identity is called an Entity.” Entities are very important in the domain model, since they are the base for a model. Therefore, you should identify and design them carefully.</p>
	<p class="block_26">An entity’s identity can cross multiple microservices or Bounded Contexts.</p>
	<p class="block_27"><span class="text_8">The same identity (that is, the same </span><span class="text_9">Id</span><span class="text_8"> value, although perhaps not the same domain entity) can be modeled across multiple Bounded Contexts or microservices. However, that does not imply that the same entity, with the same attributes and logic would be implemented in multiple Bounded Contexts. Instead, entities in each Bounded Context limit their attributes and behaviors to those required in that Bounded Context’s domain.</span></p>
	<p class="block_14">For instance, the buyer entity might have most of a person’s attributes that are defined in the user entity in the profile or identity microservice, including the identity. But the buyer entity in the ordering microservice might have fewer attributes, because only certain buyer data is related to the order process. The context of each microservice or Bounded Context impacts its domain model.</p>
	<p class="block_26">Domain entities must implement behavior in addition to implementing data attributes.</p>
	<p class="block_14">A domain entity in DDD must implement the domain logic or behavior related to the entity data (the object accessed in memory). For example, as part of an order entity class you must have business logic and operations implemented as methods for tasks such as adding an order item, data validation, and total calculation. The entity’s methods take care of the invariants and rules of the entity instead of having those rules spread across the application layer.</p>
	<p class="block_14">Figure 7-8 shows a domain entity that implements not only data attributes but operations or methods with related domain logic.</p>
	<p class="block_14"><img src="images/image-99.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image9.png" class="calibre181"/></p>
	<p class="block_23"><span class="text_6">Figure 7-8</span><i class="calibre8">. Example of a domain entity design implementing data plus behavior</i></p>
	<p class="block_14">Of course, sometimes you can have entities that do not implement any logic as part of the entity class. This can happen in child entities within an aggregate if the child entity does not have any special logic because most of the logic is defined in the aggregate root. If you have a complex microservice that has a lot of logic implemented in the service classes instead of in the domain entities, you could be falling into the anemic domain model, explained in the following section.</p>
	<h3 id="id_Toc534713735" class="block_19">Rich domain model versus anemic domain model</h3>
	<p class="block_17"><span class="text_5">In his post </span><a href="https://martinfowler.com/bliki/AnemicDomainModel.html" class="text_4">AnemicDomainModel</a><span class="text_5">, Martin Fowler describes an anemic domain model this way:</span></p>
	<p class="block_28">The basic symptom of an Anemic Domain Model is that at first blush it looks like the real thing. There are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters.</p>
	<p class="block_14">Of course, when you use an anemic domain model, those data models will be used from a set of service objects (traditionally named the <i class="calibre15">business layer</i>) which capture all the domain or business logic. The business layer sits on top of the data model and uses the data model just as data.</p>
	<p class="block_17"><span class="text_5">The anemic domain model is just a procedural style design. Anemic entity objects are not real objects because they lack behavior (methods). They only hold data properties and thus it is not object-oriented design. By putting all the behavior out into service objects (the business layer) you essentially end up with </span><a href="https://en.wikipedia.org/wiki/Spaghetti_code" class="text_4">spaghetti code</a><span class="text_5"> or </span><a href="https://martinfowler.com/eaaCatalog/transactionScript.html" class="text_4">transaction scripts</a><span class="text_5">, and therefore you lose the advantages that a domain model provides.</span></p>
	<p class="block_14">Regardless, if your microservice or Bounded Context is very simple (a CRUD service), the anemic domain model in the form of entity objects with just data properties might be good enough, and it might not be worth implementing more complex DDD patterns. In that case, it will be simply a persistence model, because you have intentionally created an entity with only data for CRUD purposes.</p>
	<p class="block_14">That is why microservices architectures are perfect for a multi-architectural approach depending on each Bounded Context. For instance, in eShopOnContainers, the ordering microservice implements DDD patterns, but the catalog microservice, which is a simple CRUD service, does not.</p>
	<p class="block_14">Some people say that the anemic domain model is an anti-pattern. It really depends on what you are implementing. If the microservice you are creating is simple enough (for example, a CRUD service), following the anemic domain model it is not an anti-pattern. However, if you need to tackle the complexity of a microservice’s domain that has a lot of ever-changing business rules, the anemic domain model might be an anti-pattern for that microservice or Bounded Context. In that case, designing it as a rich model with entities containing data plus behavior as well as implementing additional DDD patterns (aggregates, value objects, etc.) might have huge benefits for the long-term success of such a microservice.</p>
	<h4 class="block_33">Additional resources</h4>
	<ul class="list_">
	<li class="block_20"><span class="text_2">DevIQ. Domain Entity</span><span class="text_"><br class="calibre6"/></span><a href="https://deviq.com/entity/" class="text_1">https://deviq.com/entity/</a></li>
	<li class="block_20"><span class="text_2">Martin Fowler. The Domain Model</span><span class="text_"><br class="calibre6"/></span><a href="https://martinfowler.com/eaaCatalog/domainModel.html" class="text_1">https://martinfowler.com/eaaCatalog/domainModel.html</a></li>
	<li class="block_20"><span class="text_2">Martin Fowler. The Anemic Domain Model</span><span class="text_"><br class="calibre6"/></span><a href="https://martinfowler.com/bliki/AnemicDomainModel.html" class="text_1">https://martinfowler.com/bliki/AnemicDomainModel.html</a></li>
</ul>
	<h3 id="id_Toc534713736" class="block_19">The Value Object pattern</h3>
	<p class="block_14">As Eric Evans has noted, “Many objects do not have conceptual identity. These objects describe certain characteristics of a thing.”</p>
	<p class="block_14">An entity requires an identity, but there are many objects in a system that do not, like the Value Object pattern. A value object is an object with no conceptual identity that describes a domain aspect. These are objects that you instantiate to represent design elements that only concern you temporarily. You care about <i class="calibre15">what</i> they are, not <i class="calibre15">who</i> they are. Examples include numbers and strings, but can also be higher-level concepts like groups of attributes.</p>
	<p class="block_14">Something that is an entity in a microservice might not be an entity in another microservice, because in the second case, the Bounded Context might have a different meaning. For example, an address in an e-commerce application might not have an identity at all, since it might only represent a group of attributes of the customer’s profile for a person or company. In this case, the address should be classified as a value object. However, in an application for an electric power utility company, the customer address could be important for the business domain. Therefore, the address must have an identity so the billing system can be directly linked to the address. In that case, an address should be classified as a domain entity.</p>
	<p class="block_14">A person with a name and surname is usually an entity because a person has identity, even if the name and surname coincide with another set of values, such as if those names also refers to a different person.</p>
	<p class="block_14">Value objects are hard to manage in relational databases and ORMs like EF, whereas in document oriented databases they are easier to implement and use.</p>
	<p class="block_17"><span class="text_5">EF Core 2.0 includes the </span><a href="https://blogs.msdn.microsoft.com/dotnet/2017/08/14/announcing-entity-framework-core-2-0/" class="text_4">Owned Entities</a><span class="text_5"> feature that makes it easier to handle value objects, as we’ll see in detail later on.</span></p>
	<h4 class="block_33">Additional resources</h4>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Martin Fowler. Value Object pattern</span><span class="text_"> </span><a href="https://martinfowler.com/bliki/ValueObject.html" class="text_1">https://martinfowler.com/bliki/ValueObject.html</a></li>
	<li class="block_20"><span class="text_2">Value Object</span><span class="text_"> </span><a href="https://deviq.com/value-object/" class="text_1">https://deviq.com/value-object/</a></li>
	<li class="block_20"><span class="text_2">Value Objects in Test-Driven Development</span><span class="text_"> </span><a href="https://leanpub.com/tdd-ebook/read" class="text_1">https://leanpub.com/tdd-ebook/read#leanpub-auto-value-objects</a></li>
	<li class="block_20"><span class="text_2">Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.</span><span class="text_"> (Book; includes a discussion of value objects) </span><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/" class="text_1">https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/</a></li>
</ul>
	<h3 id="id_Toc534713737" class="block_19">The Aggregate pattern</h3>
	<p class="block_14">A domain model contains clusters of different data entities and processes that can control a significant area of functionality, such as order fulfillment or inventory. A more fine-grained DDD unit is the aggregate, which describes a cluster or group of entities and behaviors that can be treated as a cohesive unit.</p>
	<p class="block_14">You usually define an aggregate based on the transactions that you need. A classic example is an order that also contains a list of order items. An order item will usually be an entity. But it will be a child entity within the order aggregate, which will also contain the order entity as its root entity, typically called an aggregate root.</p>
	<p class="block_14">Identifying aggregates can be hard. An aggregate is a group of objects that must be consistent together, but you cannot just pick a group of objects and label them an aggregate. You must start with a domain concept and think about the entities that are used in the most common transactions related to that concept. Those entities that need to be transactionally consistent are what forms an aggregate. Thinking about transaction operations is probably the best way to identify aggregates.</p>
	<h3 id="id_Toc534713738" class="block_19">The Aggregate Root or Root Entity pattern</h3>
	<p class="block_14">An aggregate is composed of at least one entity: the aggregate root, also called root entity or primary entity. Additionally, it can have multiple child entities and value objects, with all entities and objects working together to implement required behavior and transactions.</p>
	<p class="block_14">The purpose of an aggregate root is to ensure the consistency of the aggregate; it should be the only entry point for updates to the aggregate through methods or operations in the aggregate root class. You should make changes to entities within the aggregate only via the aggregate root. It is the aggregate’s consistency guardian, considering all the invariants and consistency rules you might need to comply with in your aggregate. If you change a child entity or value object independently, the aggregate root cannot ensure that the aggregate is in a valid state. It would be like a table with a loose leg. Maintaining consistency is the main purpose of the aggregate root.</p>
	<p class="block_14">In Figure 7-9, you can see sample aggregates like the buyer aggregate, which contains a single entity (the aggregate root Buyer). The order aggregate contains multiple entities and a value object.</p>
	<p class="block_14"><img src="images/image-100.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image10.png" class="calibre27"/></p>
	<p class="block_23"><span class="text_6">Figure 7-9</span><i class="calibre8">. Example of aggregates with multiple or single entities</i></p>
	<p class="block_14">Note that the Buyer aggregate could have additional child entities, depending on your domain, as it does in the ordering microservice in the eShopOnContainers reference application. Figure 7-9 just illustrates a case in which the buyer has a single entity, as an example of an aggregate that contains only an aggregate root.</p>
	<p class="block_17"><span class="text_5"><img src="images/image194.tiff" alt="Image" class="calibre140"/>In order to maintain separation of aggregates and keep clear boundaries between them, it is a good practice in a DDD domain model to disallow direct navigation between aggregates and only having the foreign key (FK) field, as implemented in the </span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Order.cs" class="text_4">Ordering microservice domain model</a><span class="text_5"> in eShopOnContainers. The Order entity only has a FK field for the buyer, but not an EF Core navigation property, as shown in the following code: </span></p>
	<p class="block_14">Identifying and working with aggregates requires research and experience. For more information, see the following Additional resources list.</p>
	<h4 class="block_33">Additional resources</h4>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Vaughn Vernon. Effective Aggregate Design - Part I: Modeling a Single Aggregate</span><span class="text_"><br class="calibre6"/></span><a href="https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf" class="text_1">https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_1.pdf</a></li>
	<li class="block_20"><span class="text_2">Vaughn Vernon. Effective Aggregate Design - Part II: Making Aggregates Work Together</span><span class="text_"><br class="calibre6"/></span><a href="https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf" class="text_1">https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_2.pdf</a></li>
	<li class="block_20"><span class="text_2">Vaughn Vernon. Effective Aggregate Design - Part III: Gaining Insight Through Discovery</span><span class="text_"><br class="calibre6"/></span><a href="https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf" class="text_1">https://vaughnvernon.co/wordpress/wp-content/uploads/2014/10/DDD_COMMUNITY_ESSAY_AGGREGATES_PART_3.pdf</a></li>
	<li class="block_20"><span class="text_2">Sergey Grybniak. DDD Tactical Design Patterns</span><span class="text_"><br class="calibre6"/></span><a href="https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part" class="text_1">https://www.codeproject.com/Articles/1164363/Domain-Driven-Design-Tactical-Design-Patterns-Part</a></li>
	<li class="block_20"><span class="text_2">Chris Richardson. Developing Transactional Microservices Using Aggregates</span><span class="text_"><br class="calibre6"/></span><a href="https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson" class="text_1">https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson</a></li>
	<li class="block_20"><span class="text_2">DevIQ. The Aggregate pattern</span><span class="text_"><br class="calibre6"/></span><a href="https://deviq.com/aggregate-pattern/" class="text_1">https://deviq.com/aggregate-pattern/</a></li>
</ul>
	<h1 id="id_Toc534713739" class="block_24">Implement a microservice domain model with .NET Core</h1>
	<p class="block_14">In the previous section, the fundamental design principles and patterns for designing a domain model were explained. Now it is time to explore possible ways to implement the domain model by using .NET Core (plain C# code) and EF Core. Note that your domain model will be composed simply of your code. It will have just the EF Core model requirements, but not real dependencies on EF. You should not have hard dependencies or references to EF Core or any other ORM in your domain model.</p>
	<h2 id="id_Toc534713740" class="block_18">Domain model structure in a custom .NET Standard Library</h2>
	<p class="block_14">The folder organization used for the eShopOnContainers reference application demonstrates the DDD model for the application. You might find that a different folder organization more clearly communicates the design choices made for your application. As you can see in Figure 7-10, in the ordering domain model there are two aggregates, the order aggregate and the buyer aggregate. Each aggregate is a group of domain entities and value objects, although you could have an aggregate composed of a single domain entity (the aggregate root or root entity) as well.</p>
	<p class="block_14"><img src="images/image-101.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image11.png" class="calibre182"/></p>
	<p class="block_23"><span class="text_6">Figure 7-10</span><i class="calibre8">. Domain model structure for the ordering microservice in eShopOnContainers</i></p>
	<p class="block_14">Additionally, the domain model layer includes the repository contracts (interfaces) that are the infrastructure requirements of your domain model. In other words, these interfaces express what repositories and the methods the infrastructure layer must implement. It is critical that the implementation of the repositories be placed outside of the domain model layer, in the infrastructure layer library, so the domain model layer is not “contaminated” by API or classes from infrastructure technologies, like Entity Framework.</p>
	<p class="block_17"><span class="text_5">You can also see a </span><a href="https://martinfowler.com/bliki/Seedwork.html" class="text_4">SeedWork</a><span class="text_5"> folder that contains custom base classes that you can use as a base for your domain entities and value objects, so you do not have redundant code in each domain’s object class.</span></p>
	<h2 id="id_Toc534713741" class="block_18">Structure aggregates in a custom .NET Standard library</h2>
	<p class="block_14">An aggregate refers to a cluster of domain objects grouped together to match transactional consistency. Those objects could be instances of entities (one of which is the aggregate root or root entity) plus any additional value objects.</p>
	<p class="block_14">Transactional consistency means that an aggregate is guaranteed to be consistent and up to date at the end of a business action. For example, the order aggregate from the eShopOnContainers ordering microservice domain model is composed as shown in Figure 7-11.</p>
	<p class="block_14"><img src="images/image-102.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image12.png" class="calibre183"/></p>
	<p class="block_23"><span class="text_6">Figure 7-11</span><i class="calibre8">. The order aggregate in Visual Studio solution</i></p>
	<p class="block_17"><span class="text_5">If you open any of the files in an aggregate folder, you can see how it is marked as either a custom base class or interface, like entity or value object, as implemented in the </span><a href="https://github.com/dotnet-architecture/eShopOnContainers/tree/master/src/Services/Ordering/Ordering.Domain/SeedWork" class="text_4">SeedWork</a><span class="text_5"> folder.</span></p>
	<h2 id="id_Toc534713742" class="block_18">Implement domain entities as POCO classes</h2>
	<p class="block_14">You implement a domain model in .NET by creating POCO classes that implement your domain entities. In the following example, the Order class is defined as an entity and also as an aggregate root. Because the Order class derives from the Entity base class, it can reuse common code related to entities. Bear in mind that these base classes and interfaces are defined by you in the domain model project, so it is your code, not infrastructure code from an ORM like EF.</p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_14"><img src="images/image197.tiff" alt="Image" class="calibre184"/>It is important to note that this is a domain entity implemented as a POCO class. It does not have any direct dependency on Entity Framework Core or any other infrastructure framework. This implementation is as it should be in DDD, just C# code implementing a domain model.</p>
	<p class="block_14">In addition, the class is decorated with an interface named IAggregateRoot. That interface is an empty interface, sometimes called a <i class="calibre15">marker interface</i>, that is used just to indicate that this entity class is also an aggregate root.</p>
	<p class="block_14">A marker interface is sometimes considered as an anti-pattern; however, it is also a clean way to mark a class, especially when that interface might be evolving. An attribute could be the other choice for the marker, but it is quicker to see the base class (Entity) next to the IAggregate interface instead of putting an Aggregate attribute marker above the class. It is a matter of preferences, in any case.</p>
	<p class="block_14">Having an aggregate root means that most of the code related to consistency and business rules of the aggregate’s entities should be implemented as methods in the Order aggregate root class (for example, AddOrderItem when adding an OrderItem object to the aggregate). You should not create or update OrderItems objects independently or directly; the AggregateRoot class must keep control and consistency of any update operation against its child entities.</p>
	<h2 id="id_Toc534713743" class="block_18">Encapsulate data in the Domain Entities</h2>
	<p class="block_14">A common problem in entity models is that they expose collection navigation properties as publicly accessible list types. This allows any collaborator developer to manipulate the contents of these collection types, which may bypass important business rules related to the collection, possibly leaving the object in an invalid state. The solution to this is to expose read-only access to related collections and explicitly provide methods that define ways in which clients can manipulate them.</p>
	<p class="block_14">In the previous code, note that many attributes are read-only or private and are only updatable by the class methods, so any update considers business domain invariants and logic specified within the class methods.</p>
	<p class="block_14"><img src="images/image198.tiff" alt="Image" class="calibre87"/>For example, following DDD patterns, <b class="calibre5">you should </b><span class="text_22">not</span><b class="calibre5"> do the following</b> from any command handler method or application layer class (actually, it should be impossible for you to do so):</p>
	<p class="block_14">In this case, the Add method is purely an operation to add data, with direct access to the OrderItems collection. Therefore, most of the domain logic, rules, or validations related to that operation with the child entities will be spread across the application layer (command handlers and Web API controllers).</p>
	<p class="block_14">If you go around the aggregate root, the aggregate root cannot guarantee its invariants, its validity, or its consistency. Eventually you will have spaghetti code or transactional script code.</p>
	<p class="block_14">To follow DDD patterns, entities must not have public setters in any entity property. Changes in an entity should be driven by explicit methods with explicit ubiquitous language about the change they are performing in the entity.</p>
	<p class="block_14">Furthermore, collections within the entity (like the order items) should be read-only properties (the AsReadOnly method explained later). You should be able to update it only from within the aggregate root class methods or the child entity methods.</p>
	<p class="block_14">As you can see in the code for the Order aggregate root, all setters should be private or at least read-only externally, so that any operation against the entity’s data or its child entities has to be performed through methods in the entity class. This maintains consistency in a controlled and object-oriented way instead of implementing transactional script code.</p>
	<p class="block_14"><img src="images/image199.tiff" alt="Image" class="calibre166"/>The following code snippet shows the proper way to code the task of adding an OrderItem object to the Order aggregate. </p>
	<p class="block_14">In this snippet, most of the validations or logic related to the creation of an OrderItem object will be under the control of the Order aggregate root—in the AddOrderItem method—especially validations and logic related to other elements in the aggregate. For instance, you might get the same product item as the result of multiple calls to AddOrderItem. In that method, you could examine the product items and consolidate the same product items into a single OrderItem object with several units. Additionally, if there are different discount amounts but the product ID is the same, you would likely apply the higher discount. This principle applies to any other domain logic for the OrderItem object.</p>
	<p class="block_14">In addition, the new OrderItem(params) operation will also be controlled and performed by the AddOrderItem method from the Order aggregate root. Therefore, most of the logic or validations related to that operation (especially anything that impacts the consistency between other child entities) will be in a single place within the aggregate root. That is the ultimate purpose of the aggregate root pattern.</p>
	<p class="block_17"><span class="text_5">When you use Entity Framework Core 1.1 or later, a DDD entity can be better expressed because it allows </span><a href="https://docs.microsoft.com/ef/core/modeling/backing-field" class="text_4">mapping to fields</a><span class="text_5"> in addition to properties. This is useful when protecting collections of child entities or value objects. With this enhancement, you can use simple private fields instead of properties and you can implement any update to the field collection in public methods and provide read-only access through the AsReadOnly method.</span></p>
	<p class="block_14">In DDD you want to update the entity only through methods in the entity (or the constructor) in order to control any invariant and the consistency of the data, so properties are defined only with a get accessor. The properties are backed by private fields. Private members can only be accessed from within the class. However, there one exception: EF Core needs to set these fields as well (so it can return the object with the proper values).</p>
	<h3 id="id_Toc534713744" class="block_19">Map properties with only get accessors to the fields in the database table</h3>
	<p class="block_14">Mapping properties to database table columns is not a domain responsibility but part of the infrastructure and persistence layer. We mention this here just so you are aware of the new capabilities in EF Core 1.1 or later related to how you can model entities. Additional details on this topic are explained in the infrastructure and persistence section.</p>
	<p class="block_14">When you use EF Core 1.0 or later, within the DbContext you need to map the properties that are defined only with getters to the actual fields in the database table. This is done with the HasField method of the PropertyBuilder class.</p>
	<h3 id="id_Toc534713745" class="block_19">Map fields without properties</h3>
	<p class="block_14">With the feature in EF Core 1.1 or later to map columns to fields, it is also possible to not use properties. Instead, you can just map columns from a table to fields. A common use case for this is private fields for an internal state that does not need to be accessed from outside the entity.</p>
	<p class="block_15"><span class="text_12">For example, in the preceding OrderAggregate code example, there are several private fields, like the </span><span class="text_13">_paymentMethodId</span><span class="text_12"> field, that have no related property for either a setter or getter. That field could also be calculated within the order’s business logic and used from the order’s methods, but it needs to be persisted in the database as well. So in EF Core (since v1.1) there is a way to map a field without a related property to a column in the database. This is also explained in the </span><a href="#id_Toc534713732" class="text_14">Infrastructure layer</a><span class="text_12"> section of this guide.</span></p>
	<h3 id="id_Toc534713746" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Vaughn Vernon. Modeling Aggregates with DDD and Entity Framework.</span><span class="text_"> Note that this is </span><span class="text_20">not</span><span class="text_"> Entity Framework Core.<br class="calibre6"/></span><a href="https://vaughnvernon.co/?p=879" class="text_1">https://vaughnvernon.co/?p=879</a></li>
	<li class="block_20"><span class="text_2">Julie Lerman. Coding for Domain-Driven Design: Tips for Data-Focused Devs</span><span class="text_"><br class="calibre6"/></span><a href="https://msdn.microsoft.com/en-us/magazine/dn342868.aspx" class="text_1">https://msdn.microsoft.com/magazine/dn342868.aspx</a></li>
	<li class="block_20"><span class="text_2">Udi Dahan. How to create fully encapsulated Domain Models</span><span class="text_"><br class="calibre6"/></span><a href="http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/" class="text_1">http://udidahan.com/2008/02/29/how-to-create-fully-encapsulated-domain-models/</a></li>
</ul>
	<h1 id="id_Toc534713747" class="block_24">Seedwork (reusable base classes and interfaces for your domain model)</h1>
	<p class="block_17"><span class="text_5">The solution folder contains a </span><span class="text_10">SeedWork</span><span class="text_5"> folder. This folder contains custom base classes that you can use as a base for your domain entities and value objects. Use these base classes so you do not have redundant code in each domain’s object class. The folder for these types of classes is called </span><span class="text_10">SeedWork</span><span class="text_5"> and not something like </span><span class="text_10">Framework</span><span class="text_5">. It’s called </span><span class="text_10">SeedWork</span><span class="text_5"> because the folder contains just a small subset of reusable classes which cannot really be considered a framework. </span><span class="text_10">Seedwork</span><span class="text_5"> is a term introduced by </span><a href="https://www.artima.com/forums/flat.jsp?forum=106&amp;thread=8826" class="text_4">Michael Feathers</a><span class="text_5"> and popularized by </span><a href="https://martinfowler.com/bliki/Seedwork.html" class="text_4">Martin Fowler</a><span class="text_5"> but you could also name that folder Common, SharedKernel, or similar.</span></p>
	<p class="block_14">Figure 7-12 shows the classes that form the seedwork of the domain model in the ordering microservice. It has a few custom base classes like Entity, ValueObject, and Enumeration, plus a few interfaces. These interfaces (IRepository and IUnitOfWork) inform the infrastructure layer about what needs to be implemented. Those interfaces are also used through Dependency Injection from the application layer.</p>
	<p class="block_14"><img src="images/image-103.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image13.PNG" class="calibre185"/></p>
	<p class="block_23"><span class="text_6">Figure 7-12</span><i class="calibre8">. A sample set of domain model “seedwork” base classes and interfaces</i></p>
	<p class="block_14">This is the type of copy and paste reuse that many developers share between projects, not a formal framework. You can have seedworks in any layer or library. However, if the set of classes and interfaces gets big enough, you might want to create a single class library.</p>
	<h2 id="id_Toc534713748" class="block_18">The custom Entity base class</h2>
	<p class="block_17"><span class="text_5"><img src="images/Screen_Shot_2019-01-16_at_11.58.18_AM.png" alt="Image" class="calibre186"/>The following code is an example of an Entity base class where you can place code that can be used the same way by any domain entity, such as the entity ID, </span><a href="https://docs.microsoft.com/dotnet/csharp/language-reference/operators/equality-comparison-operator" class="text_4">equality operators</a><span class="text_5">, a domain event list per entity, etc.</span></p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-16_at_12.01.54_PM.png" alt="Image" class="calibre187"/>The previous code using a domain event list per entity will be explained in the next sections when focusing on domain events.</p>
	<h2 id="id_Toc534713749" class="block_18">Repository contracts (interfaces) in the domain model layer</h2>
	<p class="block_14">Repository contracts are simply .NET interfaces that express the contract requirements of the repositories to be used for each aggregate.</p>
	<p class="block_14">The repositories themselves, with EF Core code or any other infrastructure dependencies and code (Linq, SQL, etc.), must not be implemented within the domain model; the repositories should only implement the interfaces you define in the domain model.</p>
	<p class="block_17"><span class="text_5">A pattern related to this practice (placing the repository interfaces in the domain model layer) is the Separated Interface pattern. As </span><a href="https://www.martinfowler.com/eaaCatalog/separatedInterface.html" class="text_4">explained</a><span class="text_5"> by Martin Fowler, “Use Separated Interface to define an interface in one package but implement it in another. This way a client that needs the dependency to the interface can be completely unaware of the implementation.”</span></p>
	<p class="block_14">Following the Separated Interface pattern enables the application layer (in this case, the Web API project for the microservice) to have a dependency on the requirements defined in the domain model, but not a direct dependency to the infrastructure/persistence layer. In addition, you can use Dependency Injection to isolate the implementation, which is implemented in the infrastructure/ persistence layer using repositories.</p>
	<p class="block_14">For example, the following example with the IOrderRepository interface defines what operations the OrderRepository class will need to implement at the infrastructure layer. In the current implementation of the application, the code just needs to add or update orders to the database, since queries are split following the simplified CQRS approach.</p>
	<h2 id="id_Toc534713750" class="block_18"><img src="images/image203.tiff" alt="Image" class="calibre188"/>Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Martin Fowler. Separated Interface.</span><span class="text_"><br class="calibre6"/></span><a href="https://www.martinfowler.com/eaaCatalog/separatedInterface.html" class="text_1">https://www.martinfowler.com/eaaCatalog/separatedInterface.html</a></li>
</ul>
	<h1 id="id_Toc534713751" class="block_24">Implement value objects</h1>
	<p class="block_14">As discussed in earlier sections about entities and aggregates, identity is fundamental for entities. However, there are many objects and data items in a system that do not require an identity and identity tracking, such as value objects.</p>
	<p class="block_14">A value object can reference other entities. For example, in an application that generates a route that describes how to get from one point to another, that route would be a value object. It would be a snapshot of points on a specific route, but this suggested route would not have an identity, even though internally it might refer to entities like City, Road, etc.</p>
	<p class="block_14">Figure 7-13 shows the Address value object within the Order aggregate.</p>
	<p class="block_14"><img src="images/image-104.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image14.png" class="calibre189"/></p>
	<p class="block_23"><span class="text_6">Figure 7-13</span><i class="calibre8">. Address value object within the Order aggregate</i></p>
	<p class="block_27"><span class="text_8">As shown in Figure 7-13, an entity is usually composed of multiple attributes. For example, the </span><span class="text_9">Order</span><span class="text_8"> entity can be modeled as an entity with an identity and composed internally of a set of attributes such as OrderId, OrderDate, OrderItems, etc. But the address, which is simply a complex-value composed of country, street, city, etc. and has no identity in this domain, must be modeled and treated as a value object.</span></p>
	<h2 id="id_Toc534713752" class="block_18">Important characteristics of value objects</h2>
	<p class="block_14">There are two main characteristics for value objects:</p>
	<ul class="list_">
	<li class="block_25">They have no identity.</li>
	<li class="block_25">They are immutable.</li>
</ul>
	<p class="block_14">The first characteristic was already discussed. Immutability is an important requirement. The values of a value object must be immutable once the object is created. Therefore, when the object is constructed, you must provide the required values, but you must not allow them to change during the object’s lifetime.</p>
	<p class="block_14">Value objects allow you to perform certain tricks for performance, thanks to their immutable nature. This is especially true in systems where there may be thousands of value object instances, many of which have the same values. Their immutable nature allows them to be reused; they can be interchangeable objects, since their values are the same and they have no identity. This type of optimization can sometimes make a difference between software that runs slowly and software with good performance. Of course, all these cases depend on the application environment and deployment context.</p>
	<h2 id="id_Toc534713753" class="block_18">Value object implementation in C#</h2>
	<p class="block_14"><img src="images/image205.tiff" alt="Image" class="calibre190"/>In terms of implementation, you can have a value object base class that has basic utility methods like equality based on comparison between all the attributes (since a value object must not be based on identity) and other fundamental characteristics. The following example shows a value object base class used in the ordering microservice from eShopOnContainers. </p>
	<p class="block_14"><img src="images/image206.tiff" alt="Image" class="calibre191"/>You can use this class when implementing your actual value object, as with the Address value object shown in the following example:</p>
	<p class="block_14">You can see how this value object implementation of Address has no identity and therefore, no ID field, neither at the Address class not even at the ValueObject class.</p>
	<p class="block_14">Having no ID field in a class to be used by Entity Framework was not possible until EF Core 2.0 which greatly helps to implement better value objects with no ID. That is precisely the explanation of the next section.</p>
	<p class="block_14">It could be argued that value objects, being immutable, should be read only (i.e. get-only properties) and that’s indeed true. However, value objects are usually serialized and deserialized to go through message queues, and being read only, stops the deserializer from assigning values so we just leave them as private set which is read-only enough to be practical.</p>
	<h2 id="id_Toc534713754" class="block_18">How to persist value objects in the database with EF Core 2.0</h2>
	<p class="block_14">You just saw how to define a value object in your domain model. But, how can you actually persist it into the database through Entity Framework (EF) Core which usually targets entities with identity?</p>
	<h3 id="id_Toc534713755" class="block_19">Background and older approaches using EF Core 1.1</h3>
	<p class="block_17"><span class="text_5">As background, a limitation when using EF Core 1.0 and 1.1 was that you could not use </span><a href="xref:System.ComponentModel.DataAnnotations.Schema.ComplexTypeAttribute" class="text_4">complex types</a><span class="text_5"> as defined in EF 6.x in the traditional .NET Framework. Therefore, if using EF Core 1.0 or 1.1, you needed to store your value object as an EF entity with an ID field. Then, so it looked more like a value object with no identity, you could hide its ID so you make clear that the identity of a value object is not important in the domain model. You could hide that ID by using the ID as a </span><a href="https://docs.microsoft.com/ef/core/modeling/shadow-properties" class="text_4">shadow property</a><span class="text_5">. Since that configuration for hiding the ID in the model is set up in the EF infrastructure level, it would be kind of transparent for your domain model.</span></p>
	<p class="block_14"><img src="images/image207.tiff" alt="Image" class="calibre192"/>In the initial version of eShopOnContainers (.NET Core 1.1), the hidden ID needed by EF Core infrastructure was implemented in the following way in the DbContext level, using Fluent API at the infrastructure project. Therefore, the ID was hidden from the domain model point of view, but still present in the infrastructure. </p>
	<p class="block_14">However, the persistence of that value object into the database was performed like a regular entity in a different table.</p>
	<p class="block_14">With EF Core 2.0, there are new and better ways to persist value objects.</p>
	<h2 id="id_Toc534713756" class="block_18">Persist value objects as owned entity types in EF Core 2.0</h2>
	<p class="block_14">Even with some gaps between the canonical value object pattern in DDD and the owned entity type in EF Core, it’s currently the best way to persist value objects with EF Core 2.0. You can see limitations at the end of this section.</p>
	<p class="block_14">The owned entity type feature was added to EF Core since version 2.0.</p>
	<p class="block_14">An owned entity type allows you to map types that do not have their own identity explicitly defined in the domain model and are used as properties, such as a value object, within any of your entities. An owned entity type shares the same CLR type with another entity type (that is, it’s just a regular class). The entity containing the defining navigation is the owner entity. When querying the owner, the owned types are included by default.</p>
	<p class="block_14">Just by looking at the domain model, an owned type looks like it doesn’t have any identity. However, under the covers, owned types do have identity, but the owner navigation property is part of this identity.</p>
	<p class="block_14">The identity of instances of owned types is not completely their own. It consists of three components:</p>
	<ul class="list_">
	<li class="block_25">The identity of the owner</li>
	<li class="block_25">The navigation property pointing to them</li>
	<li class="block_25">In the case of collections of owned types, an independent component (not yet supported in EF Core 2.0, coming up on 2.2).</li>
</ul>
	<p class="block_14">For example, in the Ordering domain model at eShopOnContainers, as part of the Order entity, the Address value object is implemented as an owned entity type within the owner entity, which is the Order entity. Address is a type with no identity property defined in the domain model. It is used as a property of the Order type to specify the shipping address for a particular order.</p>
	<p class="block_14">By convention, a shadow primary key is created for the owned type and it will be mapped to the same table as the owner by using table splitting. This allows to use owned types similarly to how complex types are used in EF6 in the traditional .NET Framework.</p>
	<p class="block_14">It is important to note that owned types are never discovered by convention in EF Core, so you have to declare them explicitly.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-16_at_12.04.39_PM.png" alt="Image" class="calibre92"/>In eShopOnContainers, at the OrderingContext.cs, within the OnModelCreating() method, there are multiple infrastructure configuration being applied. One of them is related to the Order entity.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-16_at_12.04.44_PM.png" alt="Image" class="calibre122"/>In the following code, the persistence infrastructure is defined for the Order entity:</p>
	<p class="block_27"><span class="text_8">In the previous code, the </span><span class="text_9">orderConfiguration.OwnsOne(o =&gt; o.Address)</span><span class="text_8"> method specifies that the </span><span class="text_9">Address</span><span class="text_8"> property is an owned entity of the </span><span class="text_9">Order</span><span class="text_8"> type.</span></p>
	<p class="block_27"><span class="text_8">By default, EF Core conventions name the database columns for the properties of the owned entity type as </span><span class="text_9">EntityProperty_OwnedEntityProperty</span><span class="text_8">. Therefore, the internal properties of </span><span class="text_9">Address</span><span class="text_8"> will appear in the </span><span class="text_9">Orders</span><span class="text_8"> table with the names </span><span class="text_9">Address_Street</span><span class="text_8">, </span><span class="text_9">Address_City</span><span class="text_8"> (and so on for </span><span class="text_9">State</span><span class="text_8">, </span><span class="text_9">Country</span><span class="text_8"> and </span><span class="text_9">ZipCode</span><span class="text_8">).</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image210.tiff" alt="Image" class="calibre193"/>You can append the </span><span class="text_9">Property().HasColumnName()</span><span class="text_8"> fluent method to rename those columns. In the case where </span><span class="text_9">Address</span><span class="text_8"> is a public property, the mappings would be like the following: </span></p>
	<p class="block_27"><span class="text_8"><img src="images/image211.tiff" alt="Image" class="calibre194"/>It is possible to chain the </span><span class="text_9">OwnsOne</span><span class="text_8"> method in a fluent mapping. In the following hypothetical example, </span><span class="text_9">OrderDetails</span><span class="text_8"> owns </span><span class="text_9">BillingAddress</span><span class="text_8"> and </span><span class="text_9">ShippingAddress</span><span class="text_8">, which are both </span><span class="text_9">Address</span><span class="text_8"> types. Then </span><span class="text_9">OrderDetails</span><span class="text_8"> is owned by the </span><span class="text_9">Order</span><span class="text_8"> type. </span></p>
	<h3 id="id_Toc534713757" class="block_19">Additional details on owned entity types</h3>
	<ul class="list_">
	<li class="block_25">Owned types are defined when you configure a navigation property to a particular type using the OwnsOne fluent API.</li>
	<li class="block_25">The definition of an owned type in our metadata model is a composite of: the owner type, the navigation property, and the CLR type of the owned type.</li>
	<li class="block_25">The identity (key) of an owned type instance in our stack is a composite of the identity of the owner type and the definition of the owned type.</li>
</ul>
	<h4 id="id_ownedentitiescapabilities" class="block_33">Owned entities capabilities:</h4>
	<ul class="list_">
	<li class="block_25">Owned types can reference other entities, either owned (nested owned types) or non-owned (regular reference navigation properties to other entities).</li>
	<li class="block_25">You can map the same CLR type as different owned types in the same owner entity through separate navigation properties.</li>
	<li class="block_25">Table splitting is setup by convention, but you can opt out by mapping the owned type to a different table using ToTable.</li>
	<li class="block_25">Eager loading is performed automatically on owned types, i.e. no need to call Include() on the query.</li>
	<li class="block_25">Can be configured with attribute [Owned], as of EF Core 2.1</li>
</ul>
	<h4 id="id_ownedentitieslimitations" class="block_33">Owned entities limitations:</h4>
	<ul class="list_">
	<li class="block_25">You cannot create a DbSet&lt;T&gt; of an owned type (by design).</li>
	<li class="block_25">You cannot call ModelBuilder.Entity&lt;T&gt;() on owned types (currently by design).</li>
	<li class="block_25">No collections of owned types yet (as of EF Core 2.1, but they will be supported in 2.2).</li>
	<li class="block_25">No support for optional (that is, nullable) owned types that are mapped with the owner in the same table (i.e. using table splitting). This is because mapping is done for each property, we don’t have a separate sentinel for the null complex value a as whole.</li>
	<li class="block_25">No inheritance mapping support for owned types, but you should be able to map two leaf types of the same inheritance hierarchies as different owned types. EF Core will not reason about the fact that they are part of the same hierarchy.</li>
</ul>
	<h4 id="id_maindifferenceswithef6scomplextypes" class="block_33">Main differences with EF6’s complex types</h4>
	<ul class="list_">
	<li class="block_25">Table splitting is optional, i.e. they can optionally be mapped to a separate table and still be owned types.</li>
	<li class="block_25">They can reference other entities (i.e. they can act as the dependent side on relationships to other non-owned types).</li>
</ul>
	<h2 id="id_Toc534713758" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Martin Fowler. ValueObject pattern</span><span class="text_"><br class="calibre6"/></span><a href="https://martinfowler.com/bliki/ValueObject.html" class="text_1">https://martinfowler.com/bliki/ValueObject.html</a></li>
	<li class="block_20"><span class="text_2">Eric Evans. Domain-Driven Design: Tackling Complexity in the Heart of Software.</span><span class="text_"> (Book; includes a discussion of value objects)<br class="calibre6"/></span><a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/" class="text_1">https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/</a></li>
	<li class="block_20"><span class="text_2">Vaughn Vernon. Implementing Domain-Driven Design.</span><span class="text_"> (Book; includes a discussion of value objects)<br class="calibre6"/></span><a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/" class="text_1">https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577/</a></li>
	<li class="block_20"><span class="text_2">Shadow Properties</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/ef/core/modeling/shadow-properties" class="text_1">https://docs.microsoft.com/ef/core/modeling/shadow-properties</a></li>
	<li class="block_20"><span class="text_2">Complex types and/or value objects</span><span class="text_">. Discussion in the EF Core GitHub repo (Issues tab)<br class="calibre6"/></span><a href="https://github.com/aspnet/EntityFramework/issues/246" class="text_1">https://github.com/aspnet/EntityFramework/issues/246</a></li>
	<li class="block_20"><span class="text_2">ValueObject.cs.</span><span class="text_"> Base value object class in eShopOnContainers.**<br class="calibre6"/></span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/ValueObject.cs" class="text_1">https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/ValueObject.cs</a></li>
	<li class="block_20"><span class="text_2">Address class.</span><span class="text_"> Sample value object class in eShopOnContainers.<br class="calibre6"/></span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Address.cs" class="text_1">https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/OrderAggregate/Address.cs</a></li>
</ul>
	<h1 id="id_Toc534713759" class="block_24">Use enumeration classes instead of enum types</h1>
	<p class="block_17"><a href="https://docs.microsoft.com/docs/csharp/language-reference/keywords/enum" class="text_4">Enumerations</a><span class="text_5"> (or </span><span class="text_10">enum types</span><span class="text_5"> for short) are a thin language wrapper around an integral type. You might want to limit their use to when you are storing one value from a closed set of values. Classification based on sizes (small, medium, large) is a good example. Using enums for control flow or more robust abstractions can be a </span><a href="http://deviq.com/code-smells/" class="text_4">code smell</a><span class="text_5">. This type of usage leads to fragile code with many control flow statements checking values of the enum.</span></p>
	<p class="block_14">Instead, you can create Enumeration classes that enable all the rich features of an object-oriented language.</p>
	<p class="block_17"><span class="text_5">However, this isn’t a critical topic and in many cases, for simplicity, you can still use regular </span><a href="https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/enum" class="text_4">enum types</a><span class="text_5"> if that’s your preference. Anyway, the use of enumeration classes is more related to business-related concepts.</span></p>
	<h2 id="id_Toc534713760" class="block_18">Implement an Enumeration base class</h2>
	<p class="block_14"><img src="images/image212.tiff" alt="Image" class="calibre195"/>The ordering microservice in eShopOnContainers provides a sample Enumeration base class implementation, as shown in the following example: </p>
	<p class="block_27"><span class="text_8">You can use this class as a type in any entity or value object, as for the following </span><span class="text_9">CardType</span><span class="text_8"> : </span><span class="text_9">Enumeration</span><span class="text_8"> class:</span></p>
	<h2 id="id_Toc534713761" class="block_18"><img src="images/image213.tiff" alt="Image" class="calibre196"/>Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Enum’s are evil—update</span><span class="text_"><br class="calibre6"/></span><a href="https://www.planetgeek.ch/2009/07/01/enums-are-evil/" class="text_1">https://www.planetgeek.ch/2009/07/01/enums-are-evil/</a></li>
	<li class="block_20"><span class="text_2">Daniel Hardman. How Enums Spread Disease — And How To Cure It</span><span class="text_"><br class="calibre6"/></span><a href="https://codecraft.co/2012/10/29/how-enums-spread-disease-and-how-to-cure-it/" class="text_1">https://codecraft.co/2012/10/29/how-enums-spread-disease-and-how-to-cure-it/</a></li>
	<li class="block_20"><span class="text_2">Jimmy Bogard. Enumeration classes</span><span class="text_"><br class="calibre6"/></span><a href="https://lostechies.com/jimmybogard/2008/08/12/enumeration-classes/" class="text_1">https://lostechies.com/jimmybogard/2008/08/12/enumeration-classes/</a></li>
	<li class="block_20"><span class="text_2">Steve Smith. Enum Alternatives in C#</span><span class="text_"><br class="calibre6"/></span><a href="https://ardalis.com/enum-alternatives-in-c" class="text_1">https://ardalis.com/enum-alternatives-in-c</a></li>
	<li class="block_20"><span class="text_2">Enumeration.cs.</span><span class="text_"> Base Enumeration class in eShopOnContainers<br class="calibre6"/></span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/Enumeration.cs" class="text_1">https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/SeedWork/Enumeration.cs</a></li>
	<li class="block_20"><span class="text_2">CardType.cs</span><span class="text_">. Sample Enumeration class in eShopOnContainers.<br class="calibre6"/></span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/BuyerAggregate/CardType.cs" class="text_1">https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.Domain/AggregatesModel/BuyerAggregate/CardType.cs</a></li>
	<li class="block_20"><span class="text_2">SmartEnum</span><span class="text_">. Ardalis - Classes to help produce strongly typed smarter enums in .NET.<br class="calibre6"/></span><a href="https://www.nuget.org/packages/Ardalis.SmartEnum/" class="text_1">https://www.nuget.org/packages/Ardalis.SmartEnum/</a></li>
</ul>
	<h1 id="id_Toc534713762" class="block_24">Design validations in the domain model layer</h1>
	<p class="block_14">In DDD, validation rules can be thought as invariants. The main responsibility of an aggregate is to enforce invariants across state changes for all the entities within that aggregate.</p>
	<p class="block_14">Domain entities should always be valid entities. There are a certain number of invariants for an object that should always be true. For example, an order item object always has to have a quantity that must be a positive integer, plus an article name and price. Therefore, invariants enforcement is the responsibility of the domain entities (especially of the aggregate root) and an entity object should not be able to exist without being valid. Invariant rules are simply expressed as contracts, and exceptions or notifications are raised when they are violated.</p>
	<p class="block_17"><span class="text_5">The reasoning behind this is that many bugs occur because objects are in a state they should never have been in. The following is a good explanation from Greg Young in an </span><a href="https://jeffreypalermo.com/2009/05/the-fallacy-of-the-always-valid-entity/" class="text_4">online discussion</a><span class="text_5">:</span></p>
	<p class="block_28">Let’s propose we now have a SendUserCreationEmailService that takes a UserProfile … how can we rationalize in that service that Name is not null? Do we check it again? Or more likely … you just don’t bother to check and “hope for the best”—you hope that someone bothered to validate it before sending it to you. Of course, using TDD one of the first tests we should be writing is that if I send a customer with a null name that it should raise an error. But once we start writing these kinds of tests over and over again we realize … “wait if we never allowed name to become null we wouldn’t have all of these tests”</p>
	<h2 id="id_Toc534713763" class="block_18">Implement validations in the domain model layer</h2>
	<p class="block_14">Validations are usually implemented in domain entity constructors or in methods that can update the entity. There are multiple ways to implement validations, such as verifying data and raising exceptions if the validation fails. There are also more advanced patterns such as using the Specification pattern for validations, and the Notification pattern to return a collection of errors instead of returning an exception for each validation as it occurs.</p>
	<h3 id="id_Toc534713764" class="block_19">Validate conditions and throw exceptions</h3>
	<p class="block_14"><img src="images/image214.tiff" alt="Image" class="calibre197"/>The following code example shows the simplest approach to validation in a domain entity by raising an exception. In the references table at the end of this section you can see links to more advanced implementations based on the patterns we have discussed previously. </p>
	<p class="block_14">A better example would demonstrate the need to ensure that either the internal state did not change, or that all the mutations for a method occurred. For example, the following implementation would leave the object in an invalid state:</p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_14"><img src="images/image215.tiff" alt="Image" class="calibre198"/>If the value of the state is invalid, the first address line and the city have already been changed. That might make the address invalid.</p>
	<p class="block_14">A similar approach can be used in the entity’s constructor, raising an exception to make sure that the entity is valid once it is created.</p>
	<h3 id="id_Toc534713765" class="block_19">Use validation attributes in the model based on data annotations</h3>
	<p class="block_17"><span class="text_5">Data annotations, like the Required or MaxLength attributes, can be used to configure EF Core database field properties, as explained in detail in the </span><a href="index_split_011.html#id_Toc534713805" class="text_4">Table mapping</a><span class="text_5"> section, but </span><a href="https://github.com/aspnet/EntityFrameworkCore/issues/3680" class="text_4">they no longer work for entity validation in EF Core</a><span class="text_5"> (neither does the </span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.ivalidatableobject.validate?view=netcore-2.1" class="text_4">IValidatableObject.Validate()</a><span class="text_5"> method), as they have done since EF 4.x in .NET Framework.</span></p>
	<p class="block_17"><span class="text_5">Data annotations and the </span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.dataannotations.ivalidatableobject?view=netcore-2.1" class="text_4">IValidatableObject</a><span class="text_5"> interface can still be used for model validation during model binding, prior to the controller’s actions invocation as usual, but that model is meant to be a ViewModel or DTO and that’s an MVC or API concern not a domain model concern.</span></p>
	<p class="block_27"><span class="text_8">Having made the conceptual difference clear, you can still use data annotations and </span><span class="text_9">IValidatableObject</span><span class="text_8"> in the entity class for validation, if your actions receive an entity class object parameter, which is not recommended. In that case, validation will occur upon model binding, just before invoking the action and you can check the controller’s ModelState.IsValid property to check the result, but then again, it happens in the controller, not before persisting the entity object in the DbContext, as it had done since EF 4.x.</span></p>
	<p class="block_27"><span class="text_8">You can still implement custom validation in the entity class using data annotations and the </span><span class="text_9">IValidatableObject.Validate</span><span class="text_8"> method, by overriding the DbContext’s SaveChanges method.</span></p>
	<p class="block_15"><span class="text_12">You can see a sample implementation for validating </span><span class="text_13">IValidatableObject</span><span class="text_12"> entities in </span><a href="https://github.com/aspnet/EntityFrameworkCore/issues/3680" class="text_14">this comment on GitHub</a><span class="text_12">. That sample doesn’t do attribute-based validations, but they should be easy to implement using reflection in the same override.</span></p>
	<p class="block_14">However, from a DDD point of view, the domain model is best kept lean with the use of exceptions in your entity’s behavior methods, or by implementing the Specification and Notification patterns to enforce validation rules.</p>
	<p class="block_14">It can make sense to use data annotations at the application layer in ViewModel classes (instead of domain entities) that will accept input, to allow for model validation within the UI layer. However, this should not be done at the exclusion of validation within the domain model.</p>
	<h3 id="id_Toc534713766" class="block_19">Validate entities by implementing the Specification pattern and the Notification pattern</h3>
	<p class="block_14">Finally, a more elaborate approach to implementing validations in the domain model is by implementing the Specification pattern in conjunction with the Notification pattern, as explained in some of the additional resources listed later.</p>
	<p class="block_14">It is worth mentioning that you can also use just one of those patterns—for example, validating manually with control statements, but using the Notification pattern to stack and return a list of validation errors.</p>
	<h3 id="id_Toc534713767" class="block_19">Use deferred validation in the domain</h3>
	<p class="block_17"><span class="text_5">There are various approaches to deal with deferred validations in the domain. In his book </span><a href="https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577" class="text_4">Implementing Domain-Driven Design</a><span class="text_5">, Vaughn Vernon discusses these in the section on validation.</span></p>
	<h3 id="id_Toc534713768" class="block_19">Two-step validation</h3>
	<p class="block_14">Also consider two-step validation. Use field-level validation on your command Data Transfer Objects (DTOs) and domain-level validation inside your entities. You can do this by returning a result object instead exceptions in order to make it easier to deal with the validation errors.</p>
	<p class="block_14">Using field validation with data annotations, for example, you do not duplicate the validation definition. The execution, though, can be both server-side and client-side in the case of DTOs (commands and ViewModels, for instance).</p>
	<h2 id="id_Toc534713769" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Rachel Appel. Introduction to model validation in ASP.NET Core MVC</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/mvc/models/validation" class="text_1">https://docs.microsoft.com/aspnet/core/mvc/models/validation</a></li>
	<li class="block_20"><span class="text_2">Rick Anderson. Adding validation</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation" class="text_1">https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation</a></li>
	<li class="block_20"><span class="text_2">Martin Fowler. Replacing Throwing Exceptions with Notification in Validations</span><span class="text_"><br class="calibre6"/></span><a href="https://martinfowler.com/articles/replaceThrowWithNotification.html" class="text_1">https://martinfowler.com/articles/replaceThrowWithNotification.html</a></li>
	<li class="block_20"><span class="text_2">Specification and Notification Patterns</span><span class="text_"><br class="calibre6"/></span><a href="https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns" class="text_1">https://www.codeproject.com/Tips/790758/Specification-and-Notification-Patterns</a></li>
	<li class="block_20"><span class="text_2">Lev Gorodinski. Validation in Domain-Driven Design (DDD)</span><span class="text_"><br class="calibre6"/></span><a href="http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/" class="text_1">http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/</a></li>
	<li class="block_20"><span class="text_2">Colin Jack. Domain Model Validation</span><span class="text_"><br class="calibre6"/></span><a href="http://colinjack.blogspot.com/2008/03/domain-model-validation.html" class="text_1">http://colinjack.blogspot.com/2008/03/domain-model-validation.html</a></li>
	<li class="block_20"><span class="text_2">Jimmy Bogard. Validation in a DDD world</span><span class="text_"><br class="calibre6"/></span><a href="https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/" class="text_1">https://lostechies.com/jimmybogard/2009/02/15/validation-in-a-ddd-world/</a></li>
</ul>
	<h1 id="id_Toc534713770" class="block_24">Client-side validation (validation in the presentation layers)</h1>
	<p class="block_14">Even when the source of truth is the domain model and ultimately you must have validation at the domain model level, validation can still be handled at both the domain model level (server side) and the UI (client side).</p>
	<p class="block_14">Client-side validation is a great convenience for users. It saves time they would otherwise spend waiting for a round trip to the server that might return validation errors. In business terms, even a few fractions of seconds multiplied hundreds of times each day adds up to a lot of time, expense, and frustration. Straightforward and immediate validation enables users to work more efficiently and produce better quality input and output.</p>
	<p class="block_14">Just as the view model and the domain model are different, view model validation and domain model validation might be similar but serve a different purpose. If you are concerned about DRY (the Don’t Repeat Yourself principle), consider that in this case code reuse might also mean coupling, and in enterprise applications it is more important not to couple the server side to the client side than to follow the DRY principle.</p>
	<p class="block_14">Even when using client-side validation, you should always validate your commands or input DTOs in server code, because the server APIs are a possible attack vector. Usually, doing both is your best bet because if you have a client application, from a UX perspective, it is best to be proactive and not allow the user to enter invalid information.</p>
	<p class="block_14">Therefore, in client-side code you typically validate the ViewModels. You could also validate the client output DTOs or commands before you send them to the services.</p>
	<p class="block_14">The implementation of client-side validation depends on what kind of client application you are building. It will be different if you are validating data in a web MVC web application with most of the code in .NET, an SPA web application with that validation being coded in JavaScript or TypeScript, or a mobile app coded with Xamarin and C#.</p>
	<h2 id="id_Toc534713771" class="block_18">Additional resources</h2>
	<h3 id="id_Toc534713772" class="block_19">Validation in Xamarin mobile apps</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Validate Text Input and Show Errors</span><span class="text_"><br class="calibre6"/></span><a href="https://developer.xamarin.com/recipes/ios/standard_controls/text_field/validate_input/" class="text_1">https://developer.xamarin.com/recipes/ios/standard_controls/text_field/validate_input/</a></li>
	<li class="block_20"><span class="text_2">Validation Callback</span><span class="text_"><br class="calibre6"/></span><a href="https://developer.xamarin.com/samples/xamarin-forms/XAML/ValidationCallback/" class="text_1">https://developer.xamarin.com/samples/xamarin-forms/XAML/ValidationCallback/</a></li>
</ul>
	<h3 id="id_Toc534713773" class="block_19">Validation in ASP.NET Core apps</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Rick Anderson. Adding validation</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation" class="text_1">https://docs.microsoft.com/aspnet/core/tutorials/first-mvc-app/validation</a></li>
</ul>
	<h3 id="id_Toc534713774" class="block_19">Validation in SPA Web apps (Angular 2, TypeScript, JavaScript)</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Ado Kukic. Angular 2 Form Validation</span><span class="text_"><br class="calibre6"/></span><a href="https://scotch.io/tutorials/angular-2-form-validation" class="text_1">https://scotch.io/tutorials/angular-2-form-validation</a></li>
	<li class="block_20"><span class="text_2">Form Validation</span><span class="text_"><br class="calibre6"/></span><a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html" class="text_1">https://angular.io/docs/ts/latest/cookbook/form-validation.html</a></li>
	<li class="block_20"><span class="text_2">Validation.</span><span class="text_"> Breeze documentation.<br class="calibre6"/></span><a href="https://breeze.github.io/doc-js/validation.html" class="text_1">https://breeze.github.io/doc-js/validation.html</a></li>
</ul>
	<p class="block_14">In summary, these are the most important concepts in regards to validation:</p>
	<ul class="list_">
	<li class="block_25">Entities and aggregates should enforce their own consistency and be “always valid”. Aggregate roots are responsible for multi-entity consistency within the same aggregate.</li>
	<li class="block_25">If you think that an entity needs to enter an invalid state, consider using a different object model—for example, using a temporary DTO until you create the final domain entity.</li>
	<li class="block_25">If you need to create several related objects, such as an aggregate, and they are only valid once all of them have been created, consider using the Factory pattern.</li>
	<li class="block_25">In most of the cases, having redundant validation in the client side is good, because the application can be proactive.</li>
</ul>
	<h1 id="id_Toc534713775" class="block_24">Domain events: design and implementation</h1>
	<p class="block_14">Use domain events to explicitly implement side effects of changes within your domain. In other words, and using DDD terminology, use domain events to explicitly implement side effects across multiple aggregates. Optionally, for better scalability and less impact in database locks, use eventual consistency between aggregates within the same domain.</p>
	<h2 id="id_Toc534713776" class="block_18">What is a domain event?</h2>
	<p class="block_14">An event is something that has happened in the past. A domain event is, something that happened in the domain that you want other parts of the same domain (in-process) to be aware of. The notified parts usually react somehow to the events.</p>
	<p class="block_14">An important benefit of domain events is that side effects can be expressed explicitly.</p>
	<p class="block_14">For example, if you’re just using Entity Framework and there has to be a reaction to some event, you would probably code whatever you need close to what triggers the event. So the rule gets coupled, implicitly, to the code, and you have to look into the code to, hopefully, realize the rule is implemented there.</p>
	<p class="block_27"><span class="text_8">On the other hand, using domain events makes the concept explicit, because there is a </span><span class="text_9">DomainEvent</span><span class="text_8"> and at least one </span><span class="text_9">DomainEventHandler</span><span class="text_8"> involved.</span></p>
	<p class="block_27"><span class="text_8">For example, in the eShopOnContainers application, when an order is created, the user becomes a buyer, so an </span><span class="text_9">OrderStartedDomainEvent</span><span class="text_8"> is raised and handled in the </span><span class="text_9">ValidateOrAddBuyerAggregateWhenOrderStartedDomainEventHandler</span><span class="text_8">, so the underlying concept is evident.</span></p>
	<p class="block_14">In short, domain events help you to express, explicitly, the domain rules, based in the ubiquitous language provided by the domain experts. Domain events also enable a better separation of concerns among classes within the same domain.</p>
	<p class="block_14">It’s important to ensure that, just like a database transaction, either all the operations related to a domain event finish successfully or none of them do.</p>
	<p class="block_14">Domain events are similar to messaging-style events, with one important difference. With real messaging, message queuing, message brokers, or a service bus using AMPQ, a message is always sent asynchronously and communicated across processes and machines. This is useful for integrating multiple Bounded Contexts, microservices, or even different applications. However, with domain events, you want to raise an event from the domain operation you are currently running, but you want any side effects to occur within the same domain.</p>
	<p class="block_14">The domain events and their side effects (the actions triggered afterwards that are managed by event handlers) should occur almost immediately, usually in-process, and within the same domain. Thus, domain events could be synchronous or asynchronous. Integration events, however, should always be asynchronous.</p>
	<h2 id="id_Toc534713777" class="block_18">Domain events versus integration events</h2>
	<p class="block_14">Semantically, domain and integration events are the same thing: notifications about something that just happened. However, their implementation must be different. Domain events are just messages pushed to a domain event dispatcher, which could be implemented as an in-memory mediator based on an IoC container or any other method.</p>
	<p class="block_14">On the other hand, the purpose of integration events is to propagate committed transactions and updates to additional subsystems, whether they are other microservices, Bounded Contexts or even external applications. Hence, they should occur only if the entity is successfully persisted, otherwise it’s as if the entire operation never happened.</p>
	<p class="block_14">As mentioned before, integration events must be based on asynchronous communication between multiple microservices (other Bounded Contexts) or even external systems/applications.</p>
	<p class="block_14">Thus, the event bus interface needs some infrastructure that allows inter-process and distributed communication between potentially remote services. It can be based on a commercial service bus, queues, a shared database used as a mailbox, or any other distributed and ideally push based messaging system.</p>
	<h2 id="id_Toc534713778" class="block_18">Domain events as a preferred way to trigger side effects across multiple aggregates within the same domain</h2>
	<p class="block_14">If executing a command related to one aggregate instance requires additional domain rules to be run on one or more additional aggregates, you should design and implement those side effects to be triggered by domain events. As shown in Figure 7-14, and as one of the most important use cases, a domain event should be used to propagate state changes across multiple aggregates within the same domain model.</p>
	<p class="block_14"><img src="images/image-105.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image15.png" class="calibre199"/></p>
	<p class="block_23"><span class="text_6">Figure 7-14</span><i class="calibre8">. Domain events to enforce consistency between multiple aggregates within the same domain</i></p>
	<p class="block_14">In the figure, when the user initiates an order, the OrderStarted domain event triggers creation of a Buyer object in the ordering microservice, based on the original user info from the identity microservice (with information provided in the CreateOrder command). The domain event is generated by the order aggregate when it is created in the first place.</p>
	<p class="block_14">Alternately, you can have the aggregate root subscribed for events raised by members of its aggregates (child entities). For instance, each OrderItem child entity can raise an event when the item price is higher than a specific amount, or when the product item amount is too high. The aggregate root can then receive those events and perform a global calculation or aggregation.</p>
	<p class="block_14">It is important to understand that this event-based communication is not implemented directly within the aggregates; you need to implement domain event handlers.</p>
	<p class="block_14">Handling the domain events is an application concern. The domain model layer should only focus on the domain logic—things that a domain expert would understand, not application infrastructure like handlers and side-effect persistence actions using repositories. Therefore, the application layer level is where you should have domain event handlers triggering actions when a domain event is raised.</p>
	<p class="block_14">Domain events can also be used to trigger any number of application actions, and what is more important, must be open to increase that number in the future in a decoupled way. For instance, when the order is started, you might want to publish a domain event to propagate that info to other aggregates or even to raise application actions like notifications.</p>
	<p class="block_27"><span class="text_8">The key point is the open number of actions to be executed when a domain event occurs. Eventually, the actions and rules in the domain and application will grow. The complexity or number of side-effect actions when something happens will grow, but if your code were coupled with “glue” (that is, creating specific objects with </span><span class="text_9">new</span><span class="text_8">), then every time you needed to add a new action you would also need to change working and tested code.</span></p>
	<p class="block_17"><span class="text_5">This change could result in new bugs and this approach also goes against the </span><a href="https://en.wikipedia.org/wiki/Open/closed_principle" class="text_4">Open/Closed principle</a><span class="text_5"> from </span><a href="https://en.wikipedia.org/wiki/SOLID" class="text_4">SOLID</a><span class="text_5">. Not only that, the original class that was orchestrating the operations would grow and grow, which goes against the </span><a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" class="text_4">Single Responsibility Principle (SRP)</a><span class="text_5">.</span></p>
	<p class="block_14">On the other hand, if you use domain events, you can create a fine-grained and decoupled implementation by segregating responsibilities using this approach:</p>
	<ol class="list_1">
	<li class="block_25">Send a command (for example, CreateOrder).</li>
	<li class="block_25">Receive the command in a command handler.</li>
</ol>
	<div class="calibre62">
	<div class="block_30">– Execute a single aggregate’s transaction.</div>
	<div class="block_30">– (Optional) Raise domain events for side effects (for example, OrderStartedDomainEvent).</div>
</div>
	<ol class="list_1">
	<li value="3" class="block_25">Handle domain events (within the current process) that will execute an open number of side effects in multiple aggregates or application actions. For example:</li>
</ol>
	<div class="calibre62">
	<div class="block_30">– Verify or create buyer and payment method.</div>
	<div class="block_30">– Create and send a related integration event to the event bus to propagate states across microservices or trigger external actions like sending an email to the buyer.</div>
	<div class="block_30">– Handle other side effects.</div>
</div>
	<p class="block_14">As shown in Figure 7-15, starting from the same domain event, you can handle multiple actions related to other aggregates in the domain or additional application actions you need to perform across microservices connecting with integration events and the event bus.</p>
	<p class="block_14"><img src="images/image-106.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\microservice-ddd-cqrs-patterns\media\image16.png" class="calibre25"/></p>
	<p class="block_23"><span class="text_6">Figure 7-15</span><i class="calibre8">. Handling multiple actions per domain</i></p>
	<p class="block_14">The event handlers are typically in the application layer, because you will use infrastructure objects like repositories or an application API for the microservice’s behavior. In that sense, event handlers are similar to command handlers, so both are part of the application layer. The important difference is that a command should be processed only once. A domain event could be processed zero or <i class="calibre15">n</i> times, because it can be received by multiple receivers or event handlers with a different purpose for each handler.</p>
	<p class="block_14">Having an open number of handlers per domain event allows you to add as many domain rules without as needed, without affecting current code. For instance, implementing the following business rule might be as easy as adding a few event handlers (or even just one):</p>
	<p class="block_28">When the total amount purchased by a customer in the store, across any number of orders, exceeds $6,000, apply a 10% off discount to every new order and notify the customer with an email about that discount for future orders.</p>
	<h2 id="id_Toc534713779" class="block_18">Implement domain events</h2>
	<p class="block_14"><img src="images/image218.tiff" alt="Image" class="calibre200"/>In C#, a domain event is simply a data-holding structure or class, like a DTO, with all the information related to what just happened in the domain, as shown in the following example: </p>
	<p class="block_14">This is essentially a class that holds all the data related to the OrderStarted event.</p>
	<p class="block_14">In terms of the ubiquitous language of the domain, since an event is something that happened in the past, the class name of the event should be represented as a past-tense verb, like OrderStartedDomainEvent or OrderShippedDomainEvent. That’s how the domain event is implemented in the ordering microservice in eShopOnContainers.</p>
	<p class="block_14">As noted earlier, an important characteristic of events is that since an event is something that happened in the past, it should not change. Therefore, it must be an immutable class. You can see in the previous code that the properties are read-only. There’s no way to update the object, you can only set values when you create it.</p>
	<p class="block_14">It’s important to highlight here that if domain events were to be handled asynchronously, using a queue that required serializing and deserializing the event objects, the properties would have to be “private set” instead of read-only, so the deserializer would be able to assign the values upon dequeuing. This is not an issue in the Ordering microservice, as the domain event pub/sub is implemented synchronously using MediatR.</p>
	</body></html>
