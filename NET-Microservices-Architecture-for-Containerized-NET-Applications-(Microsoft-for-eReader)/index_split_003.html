<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_21" id="calibre_pb_3"> </p>
	<p id="id_Toc534713515" class="block_22">Choosing Between .NET Core and .NET Framework for Docker Containers</p>
	<p class="block_17"><span class="text_5">There are two supported frameworks for building server-side containerized Docker applications with .NET: </span><a href="https://www.microsoft.com/net/download" class="text_4">.NET Framework and .NET Core</a><span class="text_5">. They share many .NET platform components, and you can share code across the two. However, there are fundamental differences between them, and which framework you use will depend on what you want to accomplish. This section provides guidance on when to choose each framework.</span></p>
	<h1 id="id_Toc534713516" class="block_24">General guidance</h1>
	<p class="block_14">This section provides a summary of when to choose .NET Core or .NET Framework. We provide more details about these choices in the sections that follow.</p>
	<p class="block_14">You should use .NET Core, with Linux or Windows Containers, for your containerized Docker server application when:</p>
	<ul class="list_">
	<li class="block_25">You have cross-platform needs. For example, you want to use both Linux and Windows Containers.</li>
	<li class="block_25">Your application architecture is based on microservices.</li>
	<li class="block_25">You need to start containers fast and want a small footprint per container to achieve better density or more containers per hardware unit in order to lower your costs.</li>
</ul>
	<p class="block_14">In short, when you create new containerized .NET applications, you should consider .NET Core as the default choice. It has many benefits and fits best with the containers philosophy and style of working.</p>
	<p class="block_14">An additional benefit of using .NET Core is that you can run side by side .NET versions for applications within the same machine. This benefit is more important for servers or VMs that do not use containers, because containers isolate the versions of .NET that the app needs. (As long as they are compatible with the underlying OS.)</p>
	<p class="block_14">You should use .NET Framework for your containerized Docker server application when:</p>
	<ul class="list_">
	<li class="block_25">Your application currently uses .NET Framework and has strong dependencies on Windows.</li>
	<li class="block_25">You need to use Windows APIs that are not supported by .NET Core.</li>
	<li class="block_25">You need to use third-party .NET libraries or NuGet packages that are not available for .NET Core.</li>
</ul>
	<p class="block_17"><span class="text_5">Using .NET Framework on Docker can improve your deployment experiences by minimizing deployment issues. This </span><a href="https://aka.ms/liftandshiftwithcontainersebook" class="text_4">“lift and shift” scenario</a><span class="text_5"> is important for containerizing legacy applications that were originally developed with the traditional .NET Framework, like ASP.NET WebForms, MVC web apps or WCF (Windows Communication Foundation) services.</span></p>
	<h3 id="id_Toc534713517" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_25"><b class="calibre1">eBook: Modernize existing .NET Framework applications with Azure and Windows Containers</b><br class="calibre6"/>https://aka.ms/liftandshiftwithcontainersebook</li>
	<li class="block_25"><b class="calibre1">Sample apps: Modernization of legacy ASP.NET web apps by using Windows Containers</b><br class="calibre6"/>https://aka.ms/eshopmodernizing</li>
</ul>
	<h1 id="id_Toc534713518" class="block_24">When to choose .NET Core for Docker containers</h1>
	<p class="block_14">The modularity and lightweight nature of .NET Core makes it perfect for containers. When you deploy and start a container, its image is far smaller with .NET Core than with .NET Framework. In contrast, to use .NET Framework for a container, you must base your image on the Windows Server Core image, which is a lot heavier than the Windows Nano Server or Linux images that you use for .NET Core.</p>
	<p class="block_14">Additionally, .NET Core is cross-platform, so you can deploy server apps with Linux or Windows container images. However, if you are using the traditional .NET Framework, you can only deploy images based on Windows Server Core.</p>
	<p class="block_14">The following is a more detailed explanation of why to choose .NET Core.</p>
	<h2 id="id_Toc534713519" class="block_18">Developing and deploying cross platform</h2>
	<p class="block_14">Clearly, if your goal is to have an application (web app or service) that can run on multiple platforms supported by Docker (Linux and Windows), the right choice is .NET Core, because .NET Framework only supports Windows.</p>
	<p class="block_14">.NET Core also supports macOS as a development platform. However, when you deploy containers to a Docker host, that host must (currently) be based on Linux or Windows. For example, in a development environment, you could use a Linux VM running on a Mac.</p>
	<p class="block_17"><a href="https://www.visualstudio.com/vs/" class="text_4">Visual Studio</a><span class="text_5"> provides an integrated development environment (IDE) for Windows and supports Docker development.</span></p>
	<p class="block_17"><a href="https://www.visualstudio.com/vs/visual-studio-mac/" class="text_4">Visual Studio for Mac</a><span class="text_5"> is an IDE, evolution of Xamarin Studio, that runs on macOS and supports Docker-based application development. This should be the preferred choice for developers working in Mac machines who also want to use a powerful IDE.</span></p>
	<p class="block_17"><span class="text_5">You can also use </span><a href="https://code.visualstudio.com/" class="text_4">Visual Studio Code</a><span class="text_5"> (VS Code) on macOS, Linux, and Windows. VS Code fully supports .NET Core, including IntelliSense and debugging. Because VS Code is a lightweight editor, you can use it to develop containerized apps on the Mac in conjunction with the Docker CLI and the </span><a href="https://docs.microsoft.com/dotnet/core/tools/?tabs=netcore2x" class="calibre4"><span class="text_4">.NET Core command-line interface (CLI)</span></a><span class="text_5">. You can also target .NET Core with most third-party editors like Sublime, Emacs, vi, and the open-source OmniSharp project, which also provides IntelliSense support.</span></p>
	<p class="block_17"><span class="text_5">In addition to the IDEs and editors, you can use the </span><a href="https://docs.microsoft.com/dotnet/core/tools/?tabs=netcore2x" class="text_4">.NET Core CLI</a><span class="text_5"> tools for all supported platforms.</span></p>
	<h2 id="id_Toc534713520" class="block_18">Using containers for new (“green-field”) projects</h2>
	<p class="block_14">Containers are commonly used in conjunction with a microservices architecture, although they can also be used to containerize web apps or services that follow any architectural pattern. You can use .NET Framework on Windows Containers, but the modularity and lightweight nature of .NET Core makes it perfect for containers and microservices architectures. When you create and deploy a container, its image is far smaller with .NET Core than with .NET Framework.</p>
	<h2 id="id_Toc534713521" class="block_18">Creating and deploying microservices on containers</h2>
	<p class="block_14">You could use the traditional .NET Framework for building microservices-based applications (without containers) by using plain processes. That way, because the .NET Framework is already installed and shared across processes, processes are light and fast to start. However, if you are using containers, the image for the traditional .NET Framework is also based on Windows Server Core and that makes it too heavy for a microservices-on-containers approach.</p>
	<p class="block_14">In contrast, .NET Core is the best candidate if you are embracing a microservices-oriented system that is based on containers, because .NET Core is lightweight. In addition, its related container images, either the Linux image or the Windows Nano image, are lean and small making containers light and fast to start.</p>
	<p class="block_17"><span class="text_5">A microservice is meant to be as small as possible: to be light when spinning up, to have a small footprint, to have a small Bounded Context (check DDD, </span><a href="https://en.wikipedia.org/wiki/Domain-driven_design" class="text_4">Domain-Driven Design</a><span class="text_5">), to represent a small area of concerns, and to be able to start and stop fast. For those requirements, you will want to use small and fast-to-instantiate container images like the .NET Core container image.</span></p>
	<p class="block_14">A microservices architecture also allows you to mix technologies across a service boundary. This enables a gradual migration to .NET Core for new microservices that work in conjunction with other microservices or with services developed with Node.js, Python, Java, GoLang, or other technologies.</p>
	<h2 id="id_Toc534713522" class="block_18">Deploying high density in scalable systems</h2>
	<p class="block_14">When your container-based system needs the best possible density, granularity, and performance, .NET Core and ASP.NET Core are your best options. ASP.NET Core is up to ten times faster than ASP.NET in the traditional .NET Framework, and it leads other popular industry technologies for microservices, such as Java servlets, Go, and Node.js.</p>
	<p class="block_14">This is especially relevant for microservices architectures, where you could have hundreds of microservices (containers) running. With ASP.NET Core images (based on the .NET Core runtime) on Linux or Windows Nano, you can run your system with a much lower number of servers or VMs, ultimately saving costs in infrastructure and hosting.</p>
	<h1 id="id_Toc534713523" class="block_24">When to choose .NET Framework for Docker containers</h1>
	<p class="block_14">While .NET Core offers significant benefits for new applications and application patterns, .NET Framework will continue to be a good choice for many existing scenarios.</p>
	<h2 id="id_Toc534713524" class="block_18">Migrating existing applications directly to a Windows Server container</h2>
	<p class="block_14">You might want to use Docker containers just to simplify deployment, even if you are not creating microservices. For example, perhaps you want to improve your DevOps workflow with Docker—containers can give you better isolated test environments and can also eliminate deployment issues caused by missing dependencies when you move to a production environment. In cases like these, even if you are deploying a monolithic application, it makes sense to use Docker and Windows Containers for your current .NET Framework applications.</p>
	<p class="block_14">In most cases for this scenario, you will not need to migrate your existing applications to .NET Core; you can use Docker containers that include the traditional .NET Framework. However, a recommended approach is to use .NET Core as you extend an existing application, such as writing a new service in ASP.NET Core.</p>
	<h2 id="id_Toc534713525" class="block_18">Using third-party .NET libraries or NuGet packages not available for .NET Core</h2>
	<p class="block_17"><span class="text_5">Third-party libraries are quickly embracing the </span><a href="https://docs.microsoft.com/dotnet/standard/net-standard" class="text_4">.NET Standard</a><span class="text_5">, which enables code sharing across all .NET flavors, including .NET Core. With the .NET Standard Library 2.0 and beyond the API surface compatibility across different frameworks has become significantly larger and in .NET Core 2.x applications can also directly reference existing .NET Framework libraries (see </span><a href="https://github.com/dotnet/standard/blob/master/docs/netstandard-20/README.md" class="text_4">compat shim</a><span class="text_5">).</span></p>
	<p class="block_17"><span class="text_5">In addition, the </span><a href="https://docs.microsoft.com/dotnet/core/porting/windows-compat-pack" class="text_4">Windows Compatibility Pack</a><span class="text_5"> was released on NOV-2017 to extend the API surface available for .NET Standard 2.0 on Windows. This pack allows recompiling most existing code to .NET Standard 2.x with little or no modification, to run on Windows.</span></p>
	<p class="block_14">However, even with that exceptional progression since .NET Standard 2.0 and .NET Core 2.1, there might be cases where certain NuGet packages need Windows to run and might not support .NET Core. If those packages are critical for your application, then you will need to use .NET Framework on Windows Containers.</p>
	<h2 id="id_Toc534713526" class="block_18">Using .NET technologies not available for .NET Core</h2>
	<p class="block_14">Some .NET Framework technologies are not available in the current version of .NET Core (version 2.2 as of this writing). Some of them will be available in later .NET Core releases (.NET Core 2.x), but others do not apply to the new application patterns targeted by .NET Core and might never be available.</p>
	<p class="block_14">The following list shows most of the technologies that are not available in .NET Core 2.x:</p>
	<ul class="list_">
	<li class="block_25">ASP.NET Web Forms. This technology is only available on .NET Framework. Currently there are no plans to bring ASP.NET Web Forms to .NET Core.</li>
	<li class="block_20"><span class="text_">WCF services. Even when a </span><a href="https://github.com/dotnet/wcf" class="text_1">WCF-Client library</a><span class="text_"> is available to consume WCF services from .NET Core, as of mid-2017, the WCF server implementation is only available on .NET Framework. This scenario might be considered for future releases of .NET Core, there are even some APIs considered for inclusion in the </span><a href="https://docs.microsoft.com/dotnet/core/porting/windows-compat-pack" class="text_1">Windows Compatibility Pack</a><span class="text_">.</span></li>
	<li class="block_25">Workflow-related services. Windows Workflow Foundation (WF), Workflow Services (WCF + WF in a single service), and WCF Data Services (formerly known as ADO.NET Data Services) are only available on .NET Framework. There are currently no plans to bring them to .NET Core.</li>
</ul>
	<p class="block_17"><span class="text_5">In addition to the technologies listed in the official </span><a href="https://github.com/aspnet/Home/wiki/Roadmap" class="text_4">.NET Core roadmap</a><span class="text_5">, other features might be ported to .NET Core. For a full list, look at the items tagged as </span><a href="https://github.com/dotnet/corefx/issues?q=is%3Aopen+is%3Aissue+label%3Aport-to-core" class="text_4">port-to-core</a><span class="text_5"> on the CoreFX GitHub site. Note that this list does not represent a commitment from Microsoft to bring those components to .NET Core — the items simply capture requests from the community. If you care about any of the components listed above, consider participating in the discussions on GitHub so that your voice can be heard. And if you think something is missing, please </span><a href="https://github.com/dotnet/corefx/issues/new" class="text_4">file a new issue in the CoreFX repository</a><span class="text_5">.</span></p>
	<p class="block_14">Even though .NET Core 3 (at the time of this writing this is in the works) will include support for a lot of existing .NET Framework APIs, these are desktop oriented so, currently, they are of no use in the container world.</p>
	<h2 id="id_Toc534713527" class="block_18">Using a platform or API that does not support .NET Core</h2>
	<p class="block_17"><span class="text_5">Some Microsoft or third-party platforms do not support .NET Core. For example, some Azure services provide an SDK that is not yet available for consumption on .NET Core. This is temporary, because all Azure services will eventually use .NET Core. For example, the </span><a href="https://www.nuget.org/packages/Microsoft.Azure.DocumentDB.Core/1.2.1" class="text_4">Azure DocumentDB SDK for .NET Core</a><span class="text_5"> was released as a preview on November 16, 2016, but it is now generally available (GA) as a stable version.</span></p>
	<p class="block_14">In the meantime, if any platform or service in Azure still doesn’t support .NET Core with its client API, you can use the equivalent REST API from the Azure service or the client SDK on .NET Framework.</p>
	<h3 id="id_Toc534713528" class="block_19">Additional resources</h3>
	<ul class="list_">
	<li class="block_20"><span class="text_2">.NET Core Guide</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/dotnet/core/index" class="text_1">https://docs.microsoft.com/dotnet/core/index</a></li>
	<li class="block_20"><span class="text_2">Porting from .NET Framework to .NET Core</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/dotnet/core/porting/index" class="text_1">https://docs.microsoft.com/dotnet/core/porting/index</a></li>
	<li class="block_20"><span class="text_2">.NET Framework on Docker Guide</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/dotnet/framework/docker/index" class="text_1">https://docs.microsoft.com/dotnet/framework/docker/</a></li>
	<li class="block_20"><span class="text_2">.NET Components Overview</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/dotnet/standard/components" class="text_1">https://docs.microsoft.com/dotnet/standard/components</a></li>
</ul>
	<h1 id="id_Toc534713529" class="block_24">Decision table: .NET frameworks to use for Docker</h1>
	<p class="block_14">The following decision table summarizes whether to use .NET Framework or .NET Core. Remember that for Linux containers, you need Linux-based Docker hosts (VMs or servers) and that for Windows Containers you need Windows Server based Docker hosts (VMs or servers).</p>
	<p class="block_14"><b class="calibre5">IMPORTANT:</b> Your development machines will run one Docker host, either Linux or Windows. Related microservices that you want to run and test together in one solution will all need to run on the same container platform.</p>
	<h1 id="id_Toc534713530" class="block_24"><img src="images/Screen_Shot_2019-01-15_at_1.45.44_PM.png" alt="Image" class="calibre12"/>What OS to target with .NET containers</h1>
	<p class="block_14">Given the diversity of operating systems supported by Docker and the differences between .NET Framework and .NET Core, you should target a specific OS and specific versions depending on the framework you are using.</p>
	<p class="block_14">For Windows, you can use Windows Server Core or Windows Nano Server. These Windows versions provide different characteristics (IIS in Windows Server Core versus a self-hosted web server like Kestrel in Nano Server) that might be needed by .NET Framework or .NET Core, respectively.</p>
	<p class="block_14">For Linux, multiple distros are available and supported in official .NET Docker images (like Debian).</p>
	<p class="block_14">In Figure 3-1 you can see the possible OS version depending on the .NET framework used.</p>
	<p class="block_14"><img src="images/image-4.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\net-core-net-framework-containers\media\image1.png" class="calibre13"/></p>
	<p class="block_23"><span class="text_6">Figure 3-1.</span><i class="calibre8"> Operating systems to target depending on versions of the .NET framework</i></p>
	<p class="block_14">You can also create your own Docker image in cases where you want to use a different Linux distro or where you want an image with versions not provided by Microsoft. For example, you might create an image with ASP.NET Core running on the traditional .NET Framework and Windows Server Core, which is a not-so-common scenario for Docker.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_1.46.47_PM.png" alt="Image" class="calibre14"/>When you add the image name to your Dockerfile file, you can select the operating system and version depending on the tag you use, as in the following examples:</p>
	<h1 id="id_Toc534713531" class="block_24">Official .NET Docker images</h1>
	<p class="block_17"><span class="text_5">The Official .NET Docker images are Docker images created and optimized by Microsoft. They are publicly available in the Microsoft repositories on </span><a href="https://hub.docker.com/u/microsoft/" class="text_4">Docker Hub</a><span class="text_5">. Each repository can contain multiple images, depending on .NET versions, and depending on the OS and versions (Linux Debian, Linux Alpine, Windows Nano Server, Windows Server Core, etc.).</span></p>
	<p class="block_14">Since .NET Core 2.1, all the .NET Core images, including for ASP.NET Core are available at Docker Hub at the .NET Core image repo: https://hub.docker.com/r/microsoft/dotnet/</p>
	<p class="block_14">Most image repos provide extensive tagging to help you select not just a specific framework version, but also to choose an OS (Linux distro or Windows version).</p>
	<h2 id="id_Toc534713532" class="block_18">.NET Core and Docker image optimizations for development versus production</h2>
	<p class="block_14">When building Docker images for developers, Microsoft focused on the following main scenarios:</p>
	<ul class="list_">
	<li class="block_25">Images used to <i class="calibre8">develop</i> and build .NET Core apps.</li>
	<li class="block_25">Images used to <i class="calibre8">run</i> .NET Core apps.</li>
</ul>
	<p class="block_14">Why multiple images? When developing, building, and running containerized applications, you usually have different priorities. By providing different images for these separate tasks, Microsoft helps optimize the separate processes of developing, building, and deploying apps.</p>
	<h3 id="id_Toc534713533" class="block_19">During development and build</h3>
	<p class="block_14">During development, what is important is how fast you can iterate changes, and the ability to debug the changes. The size of the image is not as important as the ability to make changes to your code and see the changes quickly. Some tools and “build-agent containers”, use the development .NET Core image (<i class="calibre15">microsoft/dotnet:2.2-sdk</i>) during development and build proces. When building inside a Docker container, the important aspects are the elements that are needed in order to compile your app. This includes the compiler and any other .NET dependencies.</p>
	<p class="block_14">Why is this type of build image important? You do not deploy this image to production. Instead, it is an image you use to build the content you place into a production image. This image would be used in your continuous integration (CI) environment or build environment when using Docker Multi-stage builds.</p>
	<h3 id="id_Toc534713534" class="block_19">In production</h3>
	<p class="block_14">What is important in production is how fast you can deploy and start your containers based on a production .NET Core image. Therefore, the runtime-only image based on <i class="calibre15">microsoft/dotnet:2.2-aspnetcore-runtime</i> is small so that it can travel quickly across the network from your Docker registry to your Docker hosts. The contents are ready to run, enabling the fastest time from starting the container to processing results. In the Docker model, there is no need for compilation from C# code, as there is when you run dotnet build or dotnet publish when using the build container.</p>
	<p class="block_14">In this optimized image you put only the binaries and other content needed to run the application. For example, the content created by dotnet publish contains only the compiled .NET binaries, images, .js, and .css files. Over time, you will see images that contain pre-jitted (the compilation from IL to native that occurs at runtime) packages.</p>
	<p class="block_14">Although there are multiple versions of the .NET Core and ASP.NET Core images, they all share one or more layers, including the base layer. Therefore, the amount of disk space needed to store an image is small; it consists only of the delta between your custom image and its base image. The result is that it is quick to pull the image from your registry.</p>
	<p class="block_14"><img src="images/Screen_Shot_2019-01-15_at_1.47.27_PM.png" alt="Image" class="calibre16"/>When you explore the .NET image repositories at Docker Hub, you will find multiple image versions classified or marked with tags. These tags help to decide which one to use, depending on the version you need, like those in the following table: </p>
	<p class="block_15"> </p>
	</body></html>
