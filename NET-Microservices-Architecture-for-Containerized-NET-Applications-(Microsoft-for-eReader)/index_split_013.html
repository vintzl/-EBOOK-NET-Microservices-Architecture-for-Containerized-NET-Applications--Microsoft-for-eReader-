<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_14"><img src="images/image289.tiff" alt="Image" class="calibre134"/>The Typed Client (CatalogService in the example) is activated by DI (Dependency Injection), meaning that it can accept any registered service in its constructor, in addition to HttpClient.</p>
	<p class="block_27"><span class="text_8">A Typed Client is, effectively, a transient object, meaning that a new instance is created each time one is needed and it will receive a new </span><span class="text_9">HttpClient</span><span class="text_8"> instance each time it’s constructed. However, the HttpMessageHandler objects in the pool are the objects that are reused by multiple Http requests.</span></p>
	<h3 id="id_Toc534713850" class="block_19">Use your Typed Client classes</h3>
	<p class="block_14"><img src="images/image290.tiff" alt="Image" class="calibre175"/>Finally, once you have your type classes implemented and have them registered with AddHttpClient(), you can use it anywhere you can have services injected by DI, for example in any Razor page code or any controller of an MVC web app, like in the following code from eShopOnContainers.</p>
	<p class="block_27"><span class="text_8">Up to this point, the code shown is just performing regular Http requests, but the ‘magic’ comes in the following sections where, just by adding policies and delegating handlers to your registered Typed Clients, all the HTTP requests to be done by </span><span class="text_9">HttpClient</span><span class="text_8"> will behave taking into account resilient policies such as retries with exponential backoff, circuit breakers, or any other custom delegating handler to implement additional security features, like using auth tokens, or any other custom feature.</span></p>
	<h2 id="id_Toc534713851" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Using HttpClientFactory in .NET Core</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/fundamentals/http-requests" class="text_1">https://docs.microsoft.com/aspnet/core/fundamentals/http-requests</a></li>
	<li class="block_20"><span class="text_2">HttpClientFactory GitHub repo</span><span class="text_"><br class="calibre6"/></span><a href="https://github.com/aspnet/HttpClientFactory" class="text_1">https://github.com/aspnet/HttpClientFactory</a></li>
</ul>
	<h1 id="id_Toc534713852" class="block_24">Implement HTTP call retries with exponential backoff with HttpClientFactory and Polly policies</h1>
	<p class="block_17"><span class="text_5">The recommended approach for retries with exponential backoff is to take advantage of more advanced .NET libraries like the open-source </span><a href="https://github.com/App-vNext/Polly" class="text_4">Polly library</a><span class="text_5">.</span></p>
	<p class="block_14">Polly is a .NET library that provides resilience and transient-fault handling capabilities. You can implement those capabilities by applying Polly policies such as Retry, Circuit Breaker, Bulkhead Isolation, Timeout, and Fallback. Polly targets .NET 4.x and the .NET Standard Library 1.0 (which supports .NET Core).</p>
	<p class="block_17"><span class="text_5">However, using Polly’s library with your own custom code with HttpClient can be significantly complex. In the original version of eShopOnContainers, there was a </span><a href="https://github.com/dotnet-architecture/eShopOnContainers/blob/master/src/BuildingBlocks/Resilience/Resilience.Http/ResilientHttpClient.cs" class="text_4">ResilientHttpClient building-block</a><span class="text_5"> based on Polly. But with the release of HttpClientFactory, resilient Http communication has become much simpler to implement, so that building-block was deprecated from eShopOnContainers.</span></p>
	<p class="block_14">The following steps show how you can use Http retries with Polly integrated into HttpClientFactory, which is explained in the previous section.</p>
	<p class="block_38">Reference the ASP.NET Core 2.2 packages</p>
	<p class="block_27"><span class="text_9">HttpClientFactory</span><span class="text_8"> is available since .NET Core 2.1 however we recommend you to use the latest ASP.NET Core 2.2 packages from NuGet in your project. You typically need the </span><span class="text_9">AspNetCore</span><span class="text_8"> metapackage, and the extension package </span><span class="text_9">Microsoft.Extensions.Http.Polly</span><span class="text_8">.</span></p>
	<p class="block_38">Configure a client with Polly’s Retry policy, in Startup</p>
	<p class="block_14"><img src="images/image291.tiff" alt="Image" class="calibre256"/>As shown in previous sections, you need to define a named or typed client HttpClient configuration in your standard Startup.ConfigureServices(…) method, but now, you add incremental code specifying the policy for the Http retries with exponential backoff, as below:</p>
	<p class="block_27"><span class="text_8">The </span><span class="text_17">AddPolicyHandler()</span><span class="text_8"> method is what adds policies to the </span><span class="text_9">HttpClient</span><span class="text_8"> objects you’ll use. In this case, it’s adding a Polly’s policy for Http Retries with exponential backoff.</span></p>
	<p class="block_27"><span class="text_8">To have a more modular approach, the Http Retry Policy can be defined in a separate method within the </span><span class="text_9">Startup.cs</span><span class="text_8"> file, as shown in the following code:</span></p>
	<p class="block_15"> </p>
	<p class="block_14"><img src="images/image292.tiff" alt="Image" class="calibre257"/>With Polly, you can define a Retry policy with the number of retries, the exponential backoff configuration, and the actions to take when there’s an HTTP exception, such as logging the error. In this case, the policy is configured to try six times with an exponential retry, starting at two seconds.</p>
	<p class="block_14">so it will try six times and the seconds between each retry will be exponential, starting on two seconds.</p>
	<h2 id="id_Toc534713853" class="block_18">Add a jitter strategy to the retry policy</h2>
	<p class="block_14"><img src="images/image293.tiff" alt="Image" class="calibre258"/>A regular Retry policy can impact your system in cases of high concurrency and scalability and under high contention. To overcome peaks of similar retries coming from many clients in case of partial outages, a good workaround is to add a jitter strategy to the retry algorithm/policy. This can improve the overall performance of the end-to-end system by adding randomness to the exponential backoff. This spreads out the spikes when issues arise. When you use a plain Polly policy, code to implement jitter could look like the following example: </p>
	<h2 id="id_Toc534713854" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Retry pattern</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/architecture/patterns/retry" class="text_1">https://docs.microsoft.com/azure/architecture/patterns/retry</a></li>
	<li class="block_20"><span class="text_2">Polly and HttpClientFactory</span><span class="text_"><br class="calibre6"/></span><a href="https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory" class="text_1">https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory</a></li>
	<li class="block_20"><span class="text_2">Polly (.NET resilience and transient-fault-handling library)</span><span class="text_"><br class="calibre6"/></span><a href="https://github.com/App-vNext/Polly" class="text_1">https://github.com/App-vNext/Polly</a></li>
	<li class="block_20"><span class="text_2">Marc Brooker. Jitter: Making Things Better With Randomness</span><span class="text_"><br class="calibre6"/></span><a href="https://brooker.co.za/blog/2015/03/21/backoff.html" class="text_1">https://brooker.co.za/blog/2015/03/21/backoff.html</a></li>
</ul>
	<h1 id="id_Toc534713855" class="block_24">Implement the Circuit Breaker pattern</h1>
	<p class="block_14">As noted earlier, you should handle faults that might take a variable amount of time to recover from, as might happen when you try to connect to a remote service or resource. Handling this type of fault can improve the stability and resiliency of an application.</p>
	<p class="block_14">In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections and timeouts, or if resources are responding slowly or are temporarily unavailable. These faults typically correct themselves after a short time, and a robust cloud application should be prepared to handle them by using a strategy like the “Retry pattern”.</p>
	<p class="block_14">However, there can also be situations where faults are due to unanticipated events that might take much longer to fix. These faults can range in severity from a partial loss of connectivity to the complete failure of a service. In these situations, it might be pointless for an application to continually retry an operation that’s unlikely to succeed.</p>
	<p class="block_14">Instead, the application should be coded to accept that the operation has failed and handle the failure accordingly.</p>
	<p class="block_17"><span class="text_5">Using Http retries carelessly could result in creating a Denial of Service (</span><a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" class="text_4">DoS</a><span class="text_5">) attack within your own software. As a microservice fails or performs slowly, multiple clients might repeatedly retry failed requests. That creates a dangerous risk of exponentially increasing traffic targeted at the failing service.</span></p>
	<p class="block_14">Therefore, you need some kind of defense barrier so that excessive requests stop when it isn’t worth to keep trying. That defense barrier is precisely the circuit breaker.</p>
	<p class="block_14">The Circuit Breaker pattern has a different purpose than the “Retry pattern”. The “Retry pattern” enables an application to retry an operation in the expectation that the operation will eventually succeed. The Circuit Breaker pattern prevents an application from performing an operation that’s likely to fail. An application can combine these two patterns. However, the retry logic should be sensitive to any exception returned by the circuit breaker, and it should abandon retry attempts if the circuit breaker indicates that a fault is not transient.</p>
	<h2 id="id_Toc534713856" class="block_18">Implement Circuit Breaker pattern with HttpClientFactory and Polly</h2>
	<p class="block_14">As when implementing retries, the recommended approach for circuit breakers is to take advantage of proven .NET libraries like Polly and its native integration with HttpClientFactory.</p>
	<p class="block_14">Adding a circuit breaker policy into your HttpClientFactory outgoing middleware pipeline is as simple as adding a single incremental piece of code to what you already have when using HttpClientFactory.</p>
	<p class="block_14"><img src="images/image294.tiff" alt="Image" class="calibre259"/>The only addition here to the code used for HTTP call retries is the code where you add the Circuit Breaker policy to the list of policies to use, as shown in the following incremental code, part of the ConfigureServices() method.</p>
	<p class="block_27"><span class="text_8">The </span><span class="text_9">AddPolicyHandler()</span><span class="text_8"> method is what adds policies to the </span><span class="text_9">HttpClient</span><span class="text_8"> objects you’ll use. In this case, it’s adding a Polly policy for a circuit breaker.</span></p>
	<p class="block_27"><span class="text_8">To have a more modular approach, the Circuit Breaker Policy is defined in a separate method called </span><span class="text_9">GetCircuitBreakerPolicy()</span><span class="text_8">, as shown in the following code:</span></p>
	<p class="block_39"><span class="text_5"><img src="images/image295.tiff" alt="Image" class="calibre260"/>In the code example above, the circuit breaker policy is configured so it breaks or opens the circuit when there have been five consecutive faults when retrying the Http requests. When that happens, the circuit will break for 30 seconds: in that period, calls will be failed immediately by the circuit-breaker rather than actually be placed. The policy automatically interprets </span><a href="https://docs.microsoft.com/aspnet/core/fundamentals/http-requests" class="text_4">relevant exceptions and HTTP status codes</a><span class="text_5"> as faults.</span></p>
	<p class="block_17"><span class="text_5">Circuit breakers should also be used to redirect requests to a fallback infrastructure if you had issues in a particular resource that’s deployed in a different environment than the client application or service that’s performing the HTTP call. That way, if there’s an outage in the datacenter that impacts only your backend microservices but not your client applications, the client applications can redirect to the fallback services. Polly is planning a new policy to automate this </span><a href="https://github.com/App-vNext/Polly/wiki/Polly-Roadmap" class="text_4">failover policy</a><span class="text_5"> scenario.</span></p>
	<p class="block_14">All those features are for cases where you’re managing the failover from within the .NET code, as opposed to having it managed automatically for you by Azure, with location transparency.</p>
	<p class="block_14">From a usage point of view, when using HttpClient, there’s no need to add anything new here because the code is the same than when using HttpClient with HttpClientFactory, as shown in previous sections.</p>
	<h2 id="id_Toc534713857" class="block_18">Test Http retries and circuit breakers in eShopOnContainers</h2>
	<p class="block_14">Whenever you start the eShopOnContainers solution in a Docker host, it needs to start multiple containers. Some of the containers are slower to start and initialize, like the SQL Server container. This is especially true the first time you deploy the eShopOnContainers application into Docker because it needs to set up the images and the database. The fact that some containers start slower than others can cause the rest of the services to initially throw HTTP exceptions, even if you set dependencies between containers at the docker-compose level, as explained in previous sections. Those docker-compose dependencies between containers are just at the process level. The container’s entry point process might be started, but SQL Server might not be ready for queries. The result can be a cascade of errors, and the application can get an exception when trying to consume that particular container.</p>
	<p class="block_14">You might also see this type of error on startup when the application is deploying to the cloud. In that case, orchestrators might be moving containers from one node or VM to another (that is, starting new instances) when balancing the number of containers across the cluster’s nodes.</p>
	<p class="block_14">The way ‘eShopOnContainers’ solves those issues when starting all the containers is by using the Retry pattern illustrated earlier.</p>
	<h3 id="id_Toc534713858" class="block_19">Test the circuit breaker in eShopOnContainers</h3>
	<p class="block_14">There are a few ways you can break/open the circuit and test it with eShopOnContainers.</p>
	<p class="block_14">One option is to lower the allowed number of retries to 1 in the circuit breaker policy and redeploy the whole solution into Docker. With a single retry, there’s a good chance that an HTTP request will fail during deployment, the circuit breaker will open, and you get an error.</p>
	<p class="block_14">Another option is to use custom middleware that’s implemented in the <b class="calibre5">Basket</b> microservice. When this middleware is enabled, it catches all HTTP requests and returns status code 500. You can enable the middleware by making a GET request to the failing URI, like the following:</p>
	<ul class="list_">
	<li class="block_32"><span class="text_15">GET http://localhost:5103/failing</span><span class="text_16"><br class="calibre6"/>This request returns the current state of the middleware. If the middleware is enabled, the request return status code 500. If the middleware is disabled, there’s no response.</span></li>
	<li class="block_32"><span class="text_15">GET http://localhost:5103/failing?enable</span><span class="text_16"><br class="calibre6"/>This request enables the middleware.</span></li>
	<li class="block_32"><span class="text_15">GET http://localhost:5103/failing?disable</span><span class="text_16"><br class="calibre6"/>This request disables the middleware.</span></li>
</ul>
	<p class="block_14">For instance, once the application is running, you can enable the middleware by making a request using the following URI in any browser. Note that the ordering microservice uses port 5103.</p>
	<p class="block_34">http://localhost:5103/failing?enable</p>
	<p class="block_27"><span class="text_8">You can then check the status using the URI </span><span class="text_9">http://localhost:5103/failing</span><span class="text_8">, as shown in Figure 8-5.</span></p>
	<p class="block_14"><img src="images/image-122.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\implement-resilient-applications\media\image4.png" class="calibre261"/></p>
	<p class="block_23"><span class="text_6">Figure 8-5</span><i class="calibre8">. Checking the state of the “Failing” ASP.NET middleware – In this case, disabled.</i></p>
	<p class="block_14">At this point, the Basket microservice responds with status code 500 whenever you call invoke it.</p>
	<p class="block_14">Once the middleware is running, you can try making an order from the MVC web application. Because the requests fail, the circuit will open.</p>
	<p class="block_14">In the following example, you can see that the MVC web application has a catch block in the logic for placing an order. If the code catches an open-circuit exception, it shows the user a friendly message telling them to wait.</p>
	<p class="block_4" id="calibre_pb_13"> </p>
</body></html>
