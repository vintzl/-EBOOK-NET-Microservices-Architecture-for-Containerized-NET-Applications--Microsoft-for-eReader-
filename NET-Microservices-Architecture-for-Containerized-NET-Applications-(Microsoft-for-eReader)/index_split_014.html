<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_14"><img src="images/Screen_Shot_2019-01-16_at_12.45.37_PM.png" alt="Image" class="calibre174"/>Here’s a summary. The Retry policy tries several times to make the HTTP request and gets HTTP errors. When the number of retries reaches the maximum number set for the Circuit Breaker policy (in this case, 5), the application throws a BrokenCircuitException. The result is a friendly message, as shown in Figure 8-6.</p>
	<p class="block_14"><img src="images/image-123.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\implement-resilient-applications\media\image5.png" class="calibre262"/></p>
	<p class="block_23"><span class="text_6">Figure 8-6</span><i class="calibre8">. Circuit breaker returning an error to the UI</i></p>
	<p class="block_14">You can implement different logic for when to open/break the circuit. Or you can try an HTTP request against a different back-end microservice if there’s a fallback datacenter or redundant back-end system.</p>
	<p class="block_27"><span class="text_8">Finally, another possibility for the </span><span class="text_9">CircuitBreakerPolicy</span><span class="text_8"> is to use </span><span class="text_9">Isolate</span><span class="text_8"> (which forces open and holds open the circuit) and </span><span class="text_9">Reset</span><span class="text_8"> (which closes it again). These could be used to build a utility HTTP endpoint that invokes Isolate and Reset directly on the policy. Such an HTTP endpoint could also be used, suitably secured, in production for temporarily isolating a downstream system, such as when you want to upgrade it. Or it could trip the circuit manually to protect a downstream system you suspect to be faulting.</span></p>
	<h2 id="id_Toc534713859" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Circuit Breaker pattern</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker" class="text_1">https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker</a></li>
</ul>
	<h1 id="id_Toc534713860" class="block_24">Health monitoring</h1>
	<p class="block_14">Health monitoring can allow near-real-time information about the state of your containers and microservices. Health monitoring is critical to multiple aspects of operating microservices and is especially important when orchestrators perform partial application upgrades in phases, as explained later.</p>
	<p class="block_14">Microservices-based applications often use heartbeats or health checks to enable their performance monitors, schedulers, and orchestrators to keep track of the multitude of services. If services cannot send some sort of “I’m alive” signal, either on demand or on a schedule, your application might face risks when you deploy updates, or it might just detect failures too late and not be able to stop cascading failures that can end up in major outages.</p>
	<p class="block_14">In the typical model, services send reports about their status, and that information is aggregated to provide an overall view of the state of health of your application. If you’re using an orchestrator, you can provide health information to your orchestrator’s cluster, so that the cluster can act accordingly. If you invest in high-quality health reporting that’s customized for your application, you can detect and fix issues for your running application much more easily.</p>
	<h2 id="id_Toc534713861" class="block_18">Implement health checks in ASP.NET Core services</h2>
	<p class="block_14">When developing an ASP.NET Core microservice or web application, you can use the built-in health checks feature that was released in ASP .NET Core 2.2. Like many ASP.NET Core features, health checks come with a set of services and a middleware.</p>
	<p class="block_14">Health check services and middleware are easy to use and provide capabilities that let you validate if any external resource needed for your application (like a SQL Server database or a remote API) is working properly. When you use this feature, you can also decide what it means that the resource is healthy, as we explain later.</p>
	<p id="id_Toc530398941" class="block_14">To use this feature effectively, you need to first configure services in your microservices. Second, you need a front-end application that queries for the health reports. That front-end application could be a custom reporting application, or it could be an orchestrator itself that can react accordingly to the health states.</p>
	<h3 id="id_Toc534713862" class="block_19">Use the HealthChecks feature in your back-end ASP.NET microservices</h3>
	<p class="block_14">In this section, you will learn how the HealthChecks feature is used in a sample ASP.NET Core 2.2 Web API application. Implementation of this feature in a large scale microservices like the eShopOnContainers is explained in the later section. To begin, you need to define what constitutes a healthy status for each microservice. In the sample application, the microservices are healthy if the microservice API is accessible via HTTP and its related SQL Server database is also available. </p>
	<p class="block_14">In .NET Core 2.2, with the built-in APIs, you can configure the services, add a Health Check for the microservice and its dependent SQL Server database in this way:</p>
	<p class="block_15"> </p>
	<p class="block_15"><span class="text_12"><img src="images/image299.tiff" alt="Image" class="calibre263"/>In the previous code, </span><span class="text_13">services.AddHealthChecks()</span><span class="text_12"> method configures a basic HTTP check that returns a Status code </span><span class="text_24">200</span><span class="text_12"><span class="calibre264"> with “Healthy”.  Further, </span></span><span class="text_25">AddCheck()</span><span class="text_12"> extension method configures a custom </span><span class="text_25">SqlConnectionHealthCheck</span><span class="text_12"> that checks the related SQL Database’s health. The </span><span class="text_25">AddCheck()</span><span class="text_12"> method adds a new health check with a specified name and the implementation of type </span><span class="text_25">IHealthCheck</span><span class="text_12">. You can add multiple Health Checks using AddCheck method, so a microservice will not provide a “healthy” status until all its checks are healthy. </span></p>
	<p class="block_15"><span class="text_12"><img src="images/Screen_Shot_2019-01-16_at_12.47.26_PM.png" alt="Image" class="calibre265"/></span><span class="text_25">SqlConnectionHealthCheck</span><span class="text_12"> is a custom class that implements </span><span class="text_25">IHealthCheck</span><span class="text_12">, which takes a connection string as a constructor parameter and executes a simple query to check if the connection to the SQL database is successful. It returns </span><span class="text_25">HealthCheckResult.Healthy()</span><span class="text_12"> if the query was executed successfully and a </span><span class="text_25">FailureStatus</span><span class="text_12"> with the actual exception when it fails. </span></p>
	<p class="block_15"><span class="text_12">Note that in the previous code, </span><span class="text_26">“Select 1”</span><span class="text_12"> is the query used to check the Health of the database. To monitor the availability of your microservices, orchestrators like Kubernetes and Service Fabric periodically perform health checks by sending requests to test the microservices. It is important to keep your database queries efficient so that these operations are quick and don’t result in a higher utilization of resources. </span></p>
	<p class="block_14"><img src="images/image301.tiff" alt="Image" class="calibre266"/>Finally, we create a middleware that responds to the url path “/hc”: </p>
	<p class="block_15"><span class="text_12">When the endpoint </span><span class="text_27">&lt;yourmicroservice&gt;/hc </span><span class="text_12">is invoked, it runs all the health checks that are configured in the </span><span class="text_28">AddHealthChecks()</span><span class="text_12"> method in the Startup class and shows the result.</span></p>
	<h3 id="id_Toc534713863" class="block_19">HealthChecks implementation in eShopOnContainers</h3>
	<p class="block_15"><span class="text_12">Microservices in eShopOnContainers rely on multiple services to perform its task. For example, the Catalog.API microservice from eShopOnContainers depends on many services, such as Azure Blob Storage, SQL Server, RabbitMQ. Therefore, it has several health checks added using the </span><span class="text_28">AddCheck()</span><span class="text_12"> method. For every depending service, a custom </span><span class="text_28">IHealthCheck</span><span class="text_12"> implementation that defines its respective health status needs to be added. </span></p>
	<p class="block_17"><span class="text_5">The open-source project </span><a href="https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks" class="text_4">AspNetCore.Diagnostics.HealthChecks</a><span class="text_5"> solves this problem by providing custom health check implementations for each of these enterprise services that are built on top of .NET Core 2.2. Each health check is available as an individual NuGet package that can be easily added to the project. eShopOnContainers use them extensively in all its microservices.</span></p>
	<p class="block_14">For instance, in the Catalog.API microservice, we added the following NuGet Packages:</p>
	<p class="block_14"><img src="images/image-124.png" alt="Image" class="calibre267"/></p>
	<p class="block_23"><span class="text_6">Figure 8-7</span><i class="calibre8">. Custom Health Checks implemented in Catalog.API using AspNetCore.Diagnostics.HealthChecks</i></p>
	<p class="block_14">In the following code, the health check implementations are added for each of the dependent service and then the middleware is configured.</p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_14"><img src="images/image303.tiff" alt="Image" class="calibre268"/><img src="images/image304.tiff" alt="Image" class="calibre88"/>Finally, we add the HealthCheck middleware to listen to “/hc” endpoint:</p>
	<h3 id="id_Toc534713864" class="block_19">Query your microservices to report about their health status</h3>
	<p class="block_14">When you’ve configured health checks as described in this article and you have the microservice running in Docker, you can directly check from a browser if it’s healthy.</p>
	<p class="block_27"><span class="text_8">You have to publish the container port in the Docker host, so you can access the container through the external Docker host IP or through </span><span class="text_9">localhost</span><span class="text_8">, as shown in figure 8-8.</span></p>
	<p class="block_36"><img src="images/image-125.png" alt="Image" class="calibre269"/></p>
	<p class="block_23"><span class="text_6">Figure 8-8</span><i class="calibre8">. Checking health status of a single service from a browser</i></p>
	<p class="block_14">In that test, you can see that the Catalog.API microservice (running on port 5101) is healthy, returning HTTP status 200 and status information in JSON The service also checked the health of its SQL Server database dependency and RabbitMQ and hence the health check was reported itself as healthy.</p>
	<h2 id="id_Toc534713865" class="block_18">Use watchdogs</h2>
	<p class="block_27"><span class="text_8">A watchdog is a separate service that can watch health and load across services, and report health about the microservices by querying with the </span><span class="text_9">HealthChecks</span><span class="text_8"> library introduced earlier. This can help prevent errors that would not be detected based on the view of a single service. Watchdogs also are a good place to host code that can perform remediation actions for known conditions without user interaction.</span></p>
	<p class="block_14">The eShopOnContainers sample contains a web page that displays sample health check reports, as shown in Figure 8-9. This is the simplest watchdog you could have since all it does is show the state of the microservices and web applications in eShopOnContainers. Usually, a watchdog also takes actions when it detects unhealthy states. </p>
	<p class="block_17"><span class="text_5">Fortunately, </span><a href="https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks" class="text_4">AspNetCore.Diagnostics.HealthChecks</a><span class="text_5"> also provides </span><a href="https://www.nuget.org/packages/AspNetCore.HealthChecks.UI/" class="text_4">AspNetCore.HealthChecks.UI</a><span class="text_4"> </span><span class="text_5">NuGet package that can be utilized to display the health check results from the configured URIs.</span></p>
	<p class="block_15"> </p>
	<p class="block_14"><img src="images/image-126.png" alt="Image" class="calibre270"/></p>
	<p class="block_23"><span class="text_6">Figure 8-9</span><i class="calibre8">. Sample health check report in eShopOnContainers</i></p>
	<p id="id_Toc530754618" class="block_14">In summary, this watchdog service queries each microservice’s “/hc” endpoint. This will execute all the health checks defined within it and return an overall health state depending on all those checks. The HealthChecksUI is easy to consume with a few configuration entries and two lines of code that needs to be added into the <i class="calibre15">Startup.cs</i> of the watchdog service.</p>
	<p class="block_14"><img src="images/image307.tiff" alt="Image" class="calibre271"/>Sample configuration file for health check UI: </p>
	<p class="block_14"><img src="images/image308.tiff" alt="Image" class="calibre272"/>Startup.cs files that adds HealthChecksUI. </p>
	<h2 id="id_Toc534713866" class="block_18">Health checks when using orchestrators</h2>
	<p class="block_14">To monitor the availability of your microservices, orchestrators like Kubernetes and Service Fabric periodically perform health checks by sending requests to test the microservices. When an orchestrator determines that a service/container is unhealthy, it stops routing requests to that instance. It also usually creates a new instance of that container.</p>
	<p class="block_14">For instance, most orchestrators can use health checks to manage zero-downtime deployments. Only when the status of a service/container changes to healthy will the orchestrator start routing traffic to service/container instances.</p>
	<p class="block_14">Health monitoring is especially important when an orchestrator performs an application upgrade. Some orchestrators (like Azure Service Fabric) update services in phases—for example, they might update one-fifth of the cluster surface for each application upgrade. The set of nodes that’s upgraded at the same time is referred to as an <i class="calibre15">upgrade domain</i>. After each upgrade domain has been upgraded and is available to users, that upgrade domain must pass health checks before the deployment moves to the next upgrade domain.</p>
	<p class="block_14">Another aspect of service health is reporting metrics from the service. This is an advanced capability of the health model of some orchestrators, like Service Fabric. Metrics are important when using an orchestrator because they are used to balance resource usage. Metrics also can be an indicator of system health. For example, you might have an application that has many microservices, and each instance reports a requests-per-second (RPS) metric. If one service is using more resources (memory, processor, etc.) than another service, the orchestrator could move service instances around in the cluster to try to maintain even resource utilization.</p>
	<p class="block_17"><span class="text_5">Note that Azure Service Fabric provides its own </span><a href="https://docs.microsoft.com/azure/service-fabric/service-fabric-health-introduction" class="text_4">Health Monitoring model</a><span class="text_5">, which is more advanced than simple health checks.</span></p>
	<h2 id="id_Toc534713867" class="block_18">Advanced monitoring: visualization, analysis, and alerts</h2>
	<p class="block_14">The final part of monitoring is visualizing the event stream, reporting on service performance, and alerting when an issue is detected. You can use different solutions for this aspect of monitoring.</p>
	<p class="block_17"><span class="text_5">You can use simple custom applications showing the state of your services, like the custom page shown when explaining the </span><a href="https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks" class="text_4">AspNetCore.Diagnostics.HealthChecks</a><span class="text_5">. Or you could use more advanced tools like Azure Application Insights to raise alerts based on the stream of events.</span></p>
	<p class="block_14">Finally, if you’re storing all the event streams, you can use Microsoft Power BI or other solutions like Kibana or Splunk to visualize the data.</p>
	<h2 id="id_Toc534713868" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">HealthChecks and HealthChecks UI for ASP.NET Core</span><span class="text_"> </span><span class="text_1">https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks</span></li>
	<li class="block_20"><span class="text_2">Introduction to Service Fabric health monitoring</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/service-fabric/service-fabric-health-introduction" class="text_1">https://docs.microsoft.com/azure/service-fabric/service-fabric-health-introduction</a></li>
	<li class="block_20"><span class="text_2">Azure Application Insights</span><span class="text_"><br class="calibre6"/></span><a href="https://azure.microsoft.com/services/application-insights/" class="text_1">https://azure.microsoft.com/services/application-insights/</a></li>
	<li class="block_20"><span class="text_2">Microsoft Operations Management Suite</span><span class="text_"><br class="calibre6"/></span><a href="https://www.microsoft.com/cloud-platform/operations-management-suite" class="text_1">https://www.microsoft.com/cloud-platform/operations-management-suite</a></li>
</ul>
	<p class="block_15"> </p>
	</body></html>
