<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p class="block_21" id="calibre_pb_11"> </p>
	<p id="id_Toc534713834" class="block_22">Implement Resilient Applications</p>
	<p class="block_26">Your microservice and cloud-based applications must embrace the partial failures that will certainly occur eventually. You must design your application to be resilient to those partial failures.</p>
	<p class="block_14">Resiliency is the ability to recover from failures and continue to function. It isn’t about avoiding failures but accepting the fact that failures will happen and responding to them in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state after a failure.</p>
	<p class="block_14">It’s challenging enough to design and deploy a microservices-based application. But you also need to keep your application running in an environment where some sort of failure is certain. Therefore, your application should be resilient. It should be designed to cope with partial failures, like network outages or nodes or VMs crashing in the cloud. Even microservices (containers) being moved to a different node within a cluster can cause intermittent short failures within the application.</p>
	<p class="block_14">The many individual components of your application should also incorporate health monitoring features. By following the guidelines in this chapter, you can create an application that can work smoothly in spite of transient downtime or the normal hiccups that occur in complex and cloud-based deployments.</p>
	<h1 id="id_Toc534713835" class="block_24">Handle partial failure</h1>
	<p class="block_14">In distributed systems like microservices-based applications, there’s an ever-present risk of partial failure. For instance, a single microservice/container can fail or might not be available to respond for a short time, or a single VM or server can crash. Since clients and services are separate processes, a service might not be able to respond in a timely way to a client’s request. The service might be overloaded and responding very slowly to requests or might simply not be accessible for a short time because of network issues.</p>
	<p class="block_14">For example, consider the Order details page from the eShopOnContainers sample application. If the ordering microservice is unresponsive when the user tries to submit an order, a bad implementation of the client process (the MVC web application)—for example, if the client code were to use synchronous RPCs with no timeout—would block threads indefinitely waiting for a response. Besides creating a bad user experience, every unresponsive wait consumes or blocks a thread, and threads are extremely valuable in highly scalable applications. If there are many blocked threads, eventually the application’s runtime can run out of threads. In that case, the application can become globally unresponsive instead of just partially unresponsive, as shown in Figure 8-1.</p>
	<p class="block_14"><img src="images/image-118.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\implement-resilient-applications\media\image1.png" class="calibre245"/></p>
	<p class="block_23"><span class="text_6">Figure 8-1</span><i class="calibre8">. Partial failures because of dependencies that impact service thread availability</i></p>
	<p class="block_14">In a large microservices-based application, any partial failure can be amplified, especially if most of the internal microservices interaction is based on synchronous HTTP calls (which is considered an anti-pattern). Think about a system that receives millions of incoming calls per day. If your system has a bad design that’s based on long chains of synchronous HTTP calls, these incoming calls might result in many more millions of outgoing calls (let’s suppose a ratio of 1:4) to dozens of internal microservices as synchronous dependencies. This situation is shown in Figure 8-2, especially dependency #3.</p>
	<p class="block_14"><img src="images/image-119.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\implement-resilient-applications\media\image2.png" class="calibre129"/></p>
	<p class="block_23"><span class="text_6">Figure 8-2</span><i class="calibre8">. The impact of having an incorrect design featuring long chains of HTTP requests</i></p>
	<p class="block_14">Intermittent failure is guaranteed in a distributed and cloud-based system, even if every dependency itself has excellent availability. It’s a fact you need to consider.</p>
	<p class="block_14">If you do not design and implement techniques to ensure fault tolerance, even small downtimes can be amplified. As an example, 50 dependencies each with 99.99% of availability would result in several hours of downtime each month because of this ripple effect. When a microservice dependency fails while handling a high volume of requests, that failure can quickly saturate all available request threads in each service and crash the whole application.</p>
	<p class="block_14"><img src="images/image-120.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\implement-resilient-applications\media\image3.png" class="calibre246"/></p>
	<p class="block_23"><span class="text_6">Figure 8-3</span><i class="calibre8">. Partial failure amplified by microservices with long chains of synchronous HTTP calls</i></p>
	<p class="block_17"><span class="text_5">To minimize this problem, in the section </span><a href="index_split_004.html#id_Toc534713567" class="text_4">Asynchronous microservice integration enforce microservice’s autonomy</a><span class="text_5">, this guide encourages you to use asynchronous communication across the internal microservices.</span></p>
	<p class="block_14">In addition, it’s essential that you design your microservices and client applications to handle partial failures—that is, to build resilient microservices and client applications.</p>
	<h1 id="id_Toc534713836" class="block_24">Strategies to handle partial failure</h1>
	<p class="block_14">Strategies for dealing with partial failures include the following.</p>
	<p class="block_14"><b class="calibre5">Use asynchronous communication (for example, message-based communication) across internal microservices</b>. It’s highly advisable not to create long chains of synchronous HTTP calls across the internal microservices because that incorrect design will eventually become the main cause of bad outages. On the contrary, except for the front-end communications between the client applications and the first level of microservices or fine-grained API Gateways, it’s recommended to use only asynchronous (message-based) communication once past the initial request/response cycle, across the internal microservices. Eventual consistency and event-driven architectures will help to minimize ripple effects. These approaches enforce a higher level of microservice autonomy and therefore prevent against the problem noted here.</p>
	<p class="block_17"><span class="text_7">Use retries with exponential backoff</span><span class="text_5">. This technique helps to avoid short and intermittent failures by performing call retries a certain number of times, in case the service was not available only for a short time. This might occur due to intermittent network issues or when a microservice/container is moved to a different node in a cluster. However, if these retries are not designed properly with circuit breakers, it can aggravate the ripple effects, ultimately even causing a </span><a href="https://en.wikipedia.org/wiki/Denial-of-service_attack" class="text_4">Denial of Service (DoS)</a><span class="text_5">.</span></p>
	<p class="block_14"><b class="calibre5">Work around network timeouts</b>. In general, clients should be designed not to block indefinitely and to always use timeouts when waiting for a response. Using timeouts ensures that resources are never tied up indefinitely.</p>
	<p class="block_14"><b class="calibre5">Use the Circuit Breaker pattern</b>. In this approach, the client process tracks the number of failed requests. If the error rate exceeds a configured limit, a “circuit breaker” trips so that further attempts fail immediately. (If a large number of requests are failing, that suggests the service is unavailable and that sending requests is pointless.) After a timeout period, the client should try again and, if the new requests are successful, close the circuit breaker.</p>
	<p class="block_14"><b class="calibre5">Provide fallbacks</b>. In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value. This is an approach suitable for queries, and is more complex for updates or commands.</p>
	<p class="block_17"><span class="text_7">Limit the number of queued requests</span><span class="text_5">. Clients should also impose an upper bound on the number of outstanding requests that a client microservice can send to a particular service. If the limit has been reached, it’s probably pointless to make additional requests, and those attempts should fail immediately. In terms of implementation, the Polly </span><a href="https://github.com/App-vNext/Polly/wiki/Bulkhead" class="text_4">Bulkhead Isolation</a><span class="text_5"> policy can be used to fulfill this requirement. This approach is essentially a parallelization throttle with </span><a href="https://docs.microsoft.com/dotnet/api/system.threading.semaphoreslim?view=netcore-2.1" class="text_4">SemaphoreSlim</a><span class="text_5"> as the implementation. It also permits a “queue” outside the bulkhead. You can proactively shed excess load even before execution (for example, because capacity is deemed full). This makes its response to certain failure scenarios faster than a circuit breaker would be, since the circuit breaker waits for the failures. The BulkheadPolicy object in </span><a href="http://www.thepollyproject.org/" class="text_4">Polly</a><span class="text_5"> exposes how full the bulkhead and queue are, and offers events on overflow so can also be used to drive automated horizontal scaling.</span></p>
	<h2 id="id_Toc534713837" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Resiliency patterns</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/architecture/patterns/category/resiliency" class="text_1">https://docs.microsoft.com/azure/architecture/patterns/category/resiliency</a></li>
	<li class="block_20"><span class="text_2">Adding Resilience and Optimizing Performance</span><span class="text_"><br class="calibre6"/></span><a href="https://msdn.microsoft.com/library/jj591574.aspx" class="text_1">https://msdn.microsoft.com/library/jj591574.aspx</a></li>
	<li class="block_20"><span class="text_2">Bulkhead.</span><span class="text_"> GitHub repo. Implementation with Polly policy.<br class="calibre6"/></span><a href="https://github.com/App-vNext/Polly/wiki/Bulkhead" class="text_1">https://github.com/App-vNext/Polly/wiki/Bulkhead</a></li>
	<li class="block_20"><span class="text_2">Designing resilient applications for Azure</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/architecture/resiliency/" class="text_1">https://docs.microsoft.com/azure/architecture/resiliency/</a></li>
	<li class="block_20"><span class="text_2">Transient fault handling</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/architecture/best-practices/transient-faults" class="text_1">https://docs.microsoft.com/azure/architecture/best-practices/transient-faults</a></li>
</ul>
	<h1 id="id_Toc534713838" class="block_24">Implement retries with exponential backoff</h1>
	<p class="block_17"><a href="https://docs.microsoft.com/azure/architecture/patterns/retry" class="text_4">Retries with exponential backoff</a><span class="text_5"> is a technique that retries an operation, with an exponentially increasing wait time, up to a maximum retry count has been reached (the </span><a href="https://en.wikipedia.org/wiki/Exponential_backoff" class="text_4">exponential backoff</a><span class="text_5">). This technique embraces the fact that cloud resources might intermittently be unavailable for more than a few seconds for any reason. For example, an orchestrator might be moving a container to another node in a cluster for load balancing. During that time, some requests might fail. Another example could be a database like SQL Azure, where a database can be moved to another server for load balancing, causing the database to be unavailable for a few seconds.</span></p>
	<p class="block_14">There are many approaches to implement retries logic with exponential backoff.</p>
	<h1 id="id_Toc534713839" class="block_24">Implement resilient Entity Framework Core SQL connections</h1>
	<p class="block_17"><span class="text_5">For Azure SQL DB, Entity Framework (EF) Core already provides internal database connection resiliency and retry logic. But you need to enable the Entity Framework execution strategy for each </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.entityframeworkcore.dbcontext" class="text_4">DbContext</a><span class="text_5"> connection if you want to have </span><a href="https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency" class="text_4">resilient EF Core connections</a><span class="text_5">.</span></p>
	<p class="block_14"><img src="images/image279.tiff" alt="Image" class="calibre247"/>For instance, the following code at the EF Core connection level enables resilient SQL connections that are retried if the connection fails. </p>
	<h2 id="id_Toc534713840" class="block_18">Execution strategies and explicit transactions using BeginTransaction and multiple DbContexts</h2>
	<p class="block_27"><span class="text_8">When retries are enabled in EF Core connections, each operation you perform using EF Core becomes its own retriable operation. Each query and each call to </span><span class="text_9">SaveChanges</span><span class="text_8"> will be retried as a unit if a transient failure occurs.</span></p>
	<p class="block_27"><span class="text_8">However, if your code initiates a transaction using </span><span class="text_9">BeginTransaction</span><span class="text_8">, you’re defining your own group of operations that need to be treated as a unit. Everything inside the transaction has to be rolled back if a failure occurs.</span></p>
	<p class="block_27"><span class="text_8">If you try to execute that transaction when using an EF execution strategy (retry policy) and you call </span><span class="text_9">SaveChanges</span><span class="text_8"> from multiple DbContexts, you’ll get an exception like this one:</span></p>
	<p class="block_14">System.InvalidOperationException: The configured execution strategy ‘SqlServerRetryingExecutionStrategy’ does not support user initiated transactions. Use the execution strategy returned by ‘DbContext.Database.CreateExecutionStrategy()’ to execute all the operations in the transaction as a retriable unit.</p>
	<p class="block_14"><img src="images/image280.tiff" alt="Image" class="calibre248"/>The solution is to manually invoke the EF execution strategy with a delegate representing everything that needs to be executed. If a transient failure occurs, the execution strategy will invoke the delegate again. For example, the following code show how it’s implemented in eShopOnContainers with two multiple DbContexts (_catalogContext and the IntegrationEventLogContext) when updating a product and then saving the ProductPriceChangedIntegrationEvent object, which needs to use a different DbContext. </p>
	<p class="block_15"><span class="text_12">The first </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.entityframeworkcore.dbcontext" class="text_14">DbContext</a><span class="text_12"> is </span><span class="text_13">_catalogContext</span><span class="text_12"> and the second </span><span class="text_13">DbContext</span><span class="text_12"> is within the </span><span class="text_13">_integrationEventLogService</span><span class="text_12"> object. The Commit action is performed across all </span><span class="text_13">DbContext</span><span class="text_12"> objects using an EF execution strategy.</span></p>
	<p class="block_27"><span class="text_8">To achieve this multiple </span><span class="text_9">DbContext</span><span class="text_8"> commit, the </span><span class="text_9">SaveEventAndCatalogContextChangesAsync</span><span class="text_8"> uses a </span><span class="text_9">ResilientTransaction</span><span class="text_8"> class, as shown in the following code:</span></p>
	<p class="block_15"><span class="text_14"><img src="images/image281.tiff" alt="Image" class="calibre249"/></span><span class="text_12"><img src="images/image282.tiff" alt="Image" class="calibre250"/>The </span><span class="text_13">ResilientTransaction.ExecuteAsync</span><span class="text_12"> method basically begins a transaction from the passed </span><span class="text_13">DbContext</span><span class="text_12"> (</span><span class="text_13">_catalogContext</span><span class="text_12">) and then makes the </span><span class="text_13">EventLogService</span><span class="text_12"> use that transaction to save changes from the </span><span class="text_13">IntegrationEventLogContext</span><span class="text_12"> and then commits the whole transaction.</span></p>
	<h2 id="id_Toc534713841" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Connection Resiliency and Command Interception with EF in an ASP.NET MVC Application</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application" class="text_1">https://docs.microsoft.com/aspnet/mvc/overview/getting-started/getting-started-with-ef-using-mvc/connection-resiliency-and-command-interception-with-the-entity-framework-in-an-asp-net-mvc-application</a></li>
	<li class="block_20"><span class="text_2">Cesar de la Torre. Using Resilient Entity Framework Core SQL Connections and Transactions</span><span class="text_"><br class="calibre6"/></span><a href="https://blogs.msdn.microsoft.com/cesardelatorre/2017/03/26/using-resilient-entity-framework-core-sql-connections-and-transactions-retries-with-exponential-backoff/" class="text_1">https://blogs.msdn.microsoft.com/cesardelatorre/2017/03/26/using-resilient-entity-framework-core-sql-connections-and-transactions-retries-with-exponential-backoff/</a></li>
</ul>
	<h1 id="id_Toc534713842" class="block_24">Explore custom HTTP call retries with exponential backoff</h1>
	<p class="block_14">To create resilient microservices, you need to handle possible HTTP failure scenarios. One way of handling those failures, although not recommended, is to create your own implementation of retries with exponential backoff.</p>
	<p class="block_27"><span class="text_17">Important note:</span><span class="text_8"> This section shows you how you could create your own custom code to implement HTTP call retries. However, it isn’t recommended to do it on your own but to use more powerful and reliable while simpler to use mechanisms, such as </span><span class="text_9">HttpClientFactory</span><span class="text_8"> with Polly, available since .NET Core 2.1. Those recommended approaches are explained in the next sections.</span></p>
	<p class="block_17"><span class="text_5"><img src="images/Screen_Shot_2019-01-16_at_12.42.08_PM.png" alt="Image" class="calibre251"/>As an initial exploration, you could implement your own code with a utility class for exponential backoff as in </span><a href="https://gist.github.com/CESARDELATORRE/6d7f647b29e55fdc219ee1fd2babb260" class="text_4">RetryWithExponentialBackoff.cs</a><span class="text_5">, plus code like the following.</span></p>
	<p class="block_14"><img src="images/image284.tiff" alt="Image" class="calibre138"/><img src="images/Screen_Shot_2019-01-16_at_12.42.15_PM.png" alt="Image" class="calibre252"/>Using this code in a client C# application (another Web API client microservice, an ASP.NET MVC application, or even a C# Xamarin application) is straightforward. The following example shows how, using the HttpClient class.</p>
	<p class="block_14">Remember that this code is suitable only as a proof of concept. The next sections explain how to use more sophisticated approaches while simpler, by using HttpClientFactory. HttpClientFactory is available since .NET Core 2.1, with proven resiliency libraries like Polly.</p>
	<h1 id="id_Toc534713843" class="block_24">Use HttpClientFactory to implement resilient HTTP requests</h1>
	<p class="block_15"><span class="text_13">HttpClientFactory</span><span class="text_12"> is an opinionated factory, available since .NET Core 2.1, for creating </span><a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient?view=netcore-2.1" class="text_14">HttpClient</a><span class="text_12"> instances to be used in your applications.</span></p>
	<h2 id="id_Toc534713844" class="block_18">Issues with the original HttpClient class available in .NET Core</h2>
	<p class="block_17"><span class="text_5">The original and well-known </span><a href="https://docs.microsoft.com/dotnet/api/system.net.http.httpclient?view=netstandard-2.0" class="text_4">HttpClient</a><span class="text_5"> class can be easily used, but in some cases, it isn’t being properly used by many developers.</span></p>
	<p class="block_15"><span class="text_12">As a first issue, while this class is disposable, using it with the </span><span class="text_13">using</span><span class="text_12"> statement is not the best choice because even when you dispose </span><span class="text_13">HttpClient</span><span class="text_12"> object, the underlying socket is not immediately released and can cause a serious issue named ‘sockets exhaustion’. For more information about this issue, see </span><a href="https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/" class="text_14">You’re using HttpClient wrong and it’s destabilizing your software</a><span class="text_12"> blog post.</span></p>
	<p class="block_15"><span class="text_12">Therefore, </span><span class="text_13">HttpClient</span><span class="text_12"> is intended to be instantiated once and reused throughout the life of an application. Instantiating an </span><span class="text_13">HttpClient</span><span class="text_12"> class for every request will exhaust the number of sockets available under heavy loads. That issue will result in </span><span class="text_13">SocketException</span><span class="text_12"> errors. Possible approaches to solve that problem are based on the creation of the </span><span class="text_13">HttpClient</span><span class="text_12"> object as singleton or static, as explained in this </span><a href="https://docs.microsoft.com/dotnet/csharp/tutorials/console-webapiclient" class="text_14">Microsoft article on HttpClient usage</a><span class="text_12">.</span></p>
	<p class="block_15"><span class="text_12">But there’s a second issue with </span><span class="text_13">HttpClient</span><span class="text_12"> that you can have when you use it as singleton or static object. In this case, a singleton or static </span><span class="text_13">HttpClient</span><span class="text_12"> doesn’t respect DNS changes, as explained in this </span><a href="https://github.com/dotnet/corefx/issues/11224" class="text_14">issue at the .NET Core GitHub repo</a><span class="text_12">.</span></p>
	<p class="block_27"><span class="text_8">To address those mentioned issues and make the management of </span><span class="text_9">HttpClient</span><span class="text_8"> instances easier, .NET Core 2.1 introduced a new </span><span class="text_9">HttpClientFactory</span><span class="text_8"> that can also be used to implement resilient HTTP calls by integrating Polly with it.</span></p>
	<h2 id="id_Toc534713845" class="block_18">What is HttpClientFactory</h2>
	<p class="block_27"><span class="text_9">HttpClientFactory</span><span class="text_8"> is designed to:</span></p>
	<ul class="list_">
	<li class="block_25">Provide a central location for naming and configuring logical HttpClients. For example, you may configure a client (Service Agent) that’s pre-configured to access a specific microservice.</li>
	<li class="block_32"><span class="text_16">Codify the concept of outgoing middleware via delegating handlers in </span><span class="text_15">HttpClient</span><span class="text_16"> and implementing Polly-based middleware to take advantage of Polly’s policies for resiliency.</span></li>
	<li class="block_32"><span class="text_15">HttpClient</span><span class="text_16"> already has the concept of delegating handlers that could be linked together for outgoing HTTP requests. You register http clients into the factory plus you can use a Polly handler that allows Polly policies to be used for Retry, CircuitBreakers, etc.</span></li>
	<li class="block_32"><span class="text_16">Manage the lifetime of HttpClientMessageHandlers to avoid the mentioned problems/issues that can occur when managing </span><span class="text_15">HttpClient</span><span class="text_16"> lifetimes yourself.</span></li>
</ul>
	<h2 id="id_Toc534713846" class="block_18">Multiple ways to use HttpClientFactory</h2>
	<p class="block_27"><span class="text_8">There are several ways that you can use </span><span class="text_9">HttpClientFactory</span><span class="text_8"> in your application:</span></p>
	<ul class="list_">
	<li class="block_32"><span class="text_16">Use </span><span class="text_15">HttpClientFactory</span><span class="text_16"> Directly</span></li>
	<li class="block_25">Use Named Clients</li>
	<li class="block_25">Use Typed Clients</li>
	<li class="block_25">Use Generated Clients</li>
</ul>
	<p class="block_15"><span class="text_12">For the sake of brevity, this guidance shows the most structured way to use </span><span class="text_13">HttpClientFactory</span><span class="text_12"> that’s to use Typed Clients (Service Agent pattern), but all options are documented and are currently listed in this </span><a href="https://docs.microsoft.com/aspnet/core/fundamentals/http-requests?" class="text_14">article covering HttpClientFactory usage</a><span class="text_12">.</span></p>
	<h2 id="id_Toc534713847" class="block_18">How to use Typed Clients with HttpClientFactory</h2>
	<p class="block_27"><span class="text_8">So, what’s a “Typed Client”? It’s just an </span><span class="text_9">HttpClient</span><span class="text_8"> that’s configured upon injection by the </span><span class="text_9">DefaultHttpClientFactory</span><span class="text_8">.</span></p>
	<p class="block_27"><span class="text_8">The following diagram shows how Typed Clients are used with </span><span class="text_9">HttpClientFactory</span><span class="text_8">:</span></p>
	<p class="block_14"><img src="images/image-121.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\implement-resilient-applications\media\image3.5.png" class="calibre253"/></p>
	<p class="block_23"><span class="text_6">Figure 8-4</span><i class="calibre8">. Using HttpClientFactory with Typed Client classes.</i></p>
	<p class="block_27"><span class="text_8">First, setup </span><span class="text_9">HttpClientFactory</span><span class="text_8"> in your application, adding a reference to the </span><span class="text_9">Microsoft.Extensions.Http</span><span class="text_8"> package that includes the </span><span class="text_9">AddHttpClient()</span><span class="text_8"> extension method for </span><span class="text_9">IServiceCollection</span><span class="text_8">. This extension method registers the </span><span class="text_9">DefaultHttpClientFactory</span><span class="text_8"> to be used as a singleton for the interface </span><span class="text_9">IHttpClientFactory</span><span class="text_8">. It defines a transient configuration for the </span><span class="text_9">HttpMessageHandlerBuilder</span><span class="text_8">. This message handler (</span><span class="text_9">HttpMessageHandler</span><span class="text_8"> object), taken from a pool, is used by the </span><span class="text_9">HttpClient</span><span class="text_8"> returned from the factory.</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image287.tiff" alt="Image" class="calibre254"/>In the next code, you can see how </span><span class="text_9">AddHttpClient()</span><span class="text_8"> can be used to register Typed Clients (Service Agents) that need to use </span><span class="text_9">HttpClient</span><span class="text_8">. </span></p>
	<p class="block_27"><span class="text_8">Registering the client services as shown in the previous code, makes the </span><span class="text_9">DefaultClientFactory</span><span class="text_8"> create an </span><span class="text_9">HttpClient</span><span class="text_8"> configured specifically for each service, as we’ll explain in the next paragraph.</span></p>
	<p class="block_27"><span class="text_8">Just by registering your client service class with </span><span class="text_9">AddHttpClient()</span><span class="text_8">, the </span><span class="text_9">HttpClient</span><span class="text_8"> object that will be injected into your class will use the configuration and policies provided upon registration. In the next sections, you’ll see those policies like Polly’s retries or circuit-breakers.</span></p>
	<h3 id="id_Toc534713848" class="block_19">HttpClient lifetimes</h3>
	<p class="block_27"><span class="text_8">Each time you get an </span><span class="text_9">HttpClient</span><span class="text_8"> object from the </span><span class="text_9">IHttpClientFactory</span><span class="text_8">, a new instance is returned. But each </span><span class="text_9">HttpClient</span><span class="text_8"> uses an </span><span class="text_9">HttpMessageHandler</span><span class="text_8"> that’s pooled and reused by the </span><span class="text_9">IHttpClientFactory</span><span class="text_8"> to reduce resource consumption, as long as the </span><span class="text_9">HttpMessageHandler</span><span class="text_8">’s lifetime hasn’t expired.</span></p>
	<p class="block_14">Pooling of handlers is desirable as each handler typically manages its own underlying HTTP connections; creating more handlers than necessary can result in connection delays. Some handlers also keep connections open indefinitely, which can prevent the handler from reacting to DNS changes.</p>
	<p class="block_15"><span class="text_23"><img src="images/image288.tiff" alt="Image" class="calibre255"/></span><span class="text_12">The </span><span class="text_13">HttpMessageHandler</span><span class="text_12"> objects in the pool have a lifetime that’s the length of time that an </span><span class="text_13">HttpMessageHandler</span><span class="text_12"> instance in the pool can be reused. The default value is two minutes, but it can be overridden per Typed Client. To override it, call </span><span class="text_13">SetHandlerLifetime()</span><span class="text_12"> on the </span><span class="text_13">IHttpClientBuilder</span><span class="text_12"> that’s returned when creating the client, as shown in the following code:</span><span class="text_23"> </span></p>
	<p class="block_27"><span class="text_8">Each Typed Client can have its own configured handler lifetime value. Set the lifetime to </span><span class="text_9">InfiniteTimeSpan</span><span class="text_8"> to disable handler expiry.</span></p>
	<h3 id="id_Toc534713849" class="block_19">Implement your Typed Client classes that use the injected and configured HttpClient</h3>
	<p class="block_27"><span class="text_8">As a previous step, you need to have your Typed Client classes defined, such as the classes in the sample code, like ‘BasketService’, ‘CatalogService’, ‘OrderingService’, etc. – A Typed Client is a class that accepts an </span><span class="text_9">HttpClient</span><span class="text_8"> object (injected through its constructor) and uses it to call some remote HTTP service. For example:</span></p>
	<p class="block_4" id="calibre_pb_12"> </p>
</body></html>
