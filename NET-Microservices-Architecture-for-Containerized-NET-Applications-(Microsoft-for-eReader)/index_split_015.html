<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <title>Unknown</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<p id="id_ch11" class="block_21"> </p>
	<p id="id_Toc534713869" class="block_22">Make secure .NET Microservices and Web Applications</p>
	<p class="block_14">There are so many aspects about security in microservices and web applications that the topic could easy take several books like this one so, in this section, we’ll focus on authentication, authorization, and application secrets.</p>
	<h2 id="id_Toc534713870" class="block_18">Implement authentication in .NET microservices and web applications</h2>
	<p class="block_14">It’s often necessary for resources and APIs published by a service to be limited to certain trusted users or clients. The first step to making these sorts of API-level trust decisions is authentication. Authentication is the process of reliably verify a user’s identity.</p>
	<p class="block_14">In microservice scenarios, authentication is typically handled centrally. If you’re using an API Gateway, the gateway is a good place to authenticate, as shown in Figure 9-1. If you use this approach, make sure that the individual microservices cannot be reached directly (without the API Gateway) unless additional security is in place to authenticate messages whether they come from the gateway or not.</p>
	<p class="block_14"><img src="images/image-127.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\secure-net-microservices-web-applications\media\image1.png" class="calibre273"/></p>
	<p class="block_23"><span class="text_6">Figure 9-1</span><i class="calibre8">. Centralized authentication with an API Gateway</i></p>
	<p class="block_17"><span class="text_5">If services can be accessed directly, an authentication service like Azure Active Directory or a dedicated authentication microservice acting as a security token service (STS) can be used to authenticate users. Trust decisions are shared between services with security tokens or cookies. (These tokens can be shared between applications, if needed, in ASP.NET Core with </span><a href="https://docs.microsoft.com/aspnet/core/security/data-protection/compatibility/cookie-sharing" class="text_4">data protection services</a><span class="text_5">.) This pattern is illustrated in Figure 9-2.</span></p>
	<p class="block_14"><img src="images/image-128.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\secure-net-microservices-web-applications\media\image2.png" class="calibre274"/></p>
	<p class="block_23"><span class="text_6">Figure 9-2</span><i class="calibre8">. Authentication by identity microservice; trust is shared using an authorization token</i></p>
	<h3 id="id_Toc534713871" class="block_19">Authenticate with ASP.NET Core Identity</h3>
	<p class="block_15"><span class="text_12">The primary mechanism in ASP.NET Core for identifying an application’s users is the </span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity" class="text_14">ASP.NET Core Identity</a><span class="text_12"> membership system. ASP.NET Core Identity stores user information (including sign-in information, roles, and claims) in a data store configured by the developer. Typically, the ASP.NET Core Identity data store is an Entity Framework store provided in the </span><span class="text_13">Microsoft.AspNetCore.Identity.EntityFrameworkCore</span><span class="text_12"> package. However, custom stores or other third-party packages can be used to store identity information in Azure Table Storage, CosmosDB, or other locations.</span></p>
	<p class="block_14"><img src="images/image311.tiff" alt="Image" class="calibre275"/>The following code is taken from the ASP.NET Core Web Application project template with individual user account authentication selected. It shows how to configure ASP.NET Core Identity using EntityFramework.Core in the Startup.ConfigureServices method.</p>
	<p class="block_27"><span class="text_8">Once ASP.NET Core Identity is configured, you enable it by calling app.UseIdentity in the service’s </span><span class="text_9">Startup.Configure</span><span class="text_8"> method.</span></p>
	<p class="block_14">Using ASP.NET Core Identity enables several scenarios:</p>
	<ul class="list_">
	<li class="block_25">Create new user information using the UserManager type (userManager.CreateAsync).</li>
	<li class="block_32"><span class="text_16">Authenticate users using the SignInManager type. You can use </span><span class="text_15">signInManager.SignInAsync</span><span class="text_16"> to sign in directly, or </span><span class="text_15">signInManager.PasswordSignInAsync</span><span class="text_16"> to confirm the user’s password is correct and then sign them in.</span></li>
	<li class="block_25">Identify a user based on information stored in a cookie (which is read by ASP.NET Core Identity middleware) so that subsequent requests from a browser will include a signed-in user’s identity and claims.</li>
</ul>
	<p class="block_17"><span class="text_5">ASP.NET Core Identity also supports </span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/2fa" class="text_4">two-factor authentication</a><span class="text_5">.</span></p>
	<p class="block_14">For authentication scenarios that make use of a local user data store and that persist identity between requests using cookies (as is typical for MVC web applications), ASP.NET Core Identity is a recommended solution.</p>
	<h3 id="id_Toc534713872" class="block_19">Authenticate with external providers</h3>
	<p class="block_17"><span class="text_5">ASP.NET Core also supports using </span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/social/" class="text_4">external authentication providers</a><span class="text_5"> to let users sign in via </span><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" class="text_4">OAuth 2.0</a><span class="text_5"> flows. This means that users can sign in using existing authentication processes from providers like Microsoft, Google, Facebook, or Twitter and associate those identities with an ASP.NET Core identity in your application.</span></p>
	<p class="block_14">To use external authentication, you include the appropriate authentication middleware in your application’s HTTP request processing pipeline. This middleware is responsible for handling requests to return URI routes from the authentication provider, capturing identity information, and making it available via the SignInManager.GetExternalLoginInfo method.</p>
	<p class="block_14"><img src="images/image312.tiff" alt="Image" class="calibre276"/>Popular external authentication providers and their associated NuGet packages are shown below.</p>
	<p class="block_15"><span class="text_12">In all cases, the middleware is registered with a call to a registration method similar to </span><span class="text_13">app.Use{ExternalProvider}Authentication</span><span class="text_12"> in </span><span class="text_13">Startup.Configure</span><span class="text_12">. These registration methods take an options object that contains an application ID and secret information (a password, for instance), as needed by the provider. External authentication providers require the application to be registered (as explained in </span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/social/" class="text_14">ASP.NET Core documentation</a><span class="text_12">) so that they can inform the user what application is requesting access to their identity.</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image313.tiff" alt="Image" class="calibre277"/>Once the middleware is registered in </span><span class="text_9">Startup.Configure</span><span class="text_8">, you can prompt users to sign in from any controller action. To do this, you create an </span><span class="text_9">AuthenticationProperties</span><span class="text_8"> object that includes the authentication provider’s name and a redirect URL. You then return a Challenge response that passes the </span><span class="text_9">AuthenticationProperties</span><span class="text_8"> object. The following code shows an example of this.</span></p>
	<p class="block_14">The redirectUrl parameter includes the URL that the external provider should redirect to once the user has authenticated. The URL should represent an action that will sign the user in based on external identity information, as in the following simplified example:</p>
	<p class="block_14"><img src="images/image314.tiff" alt="Image" class="calibre278"/>If you choose the <b class="calibre5">Individual User Account</b> authentication option when you create the ASP.NET Code web application project in Visual Studio, all the code necessary to sign in with an external provider is already in the project, as shown in Figure 9-3.</p>
	<p class="block_14"><img src="images/image-129.png" alt="C:\Users\Miguel\source\repos\dotnet\docs\docs\standard\microservices-architecture\secure-net-microservices-web-applications\media\image3.png" class="calibre54"/></p>
	<p class="block_23"><span class="text_6">Figure 9-3</span><i class="calibre8">. Selecting an option for using external authentication when creating a web application project</i></p>
	<p class="block_17"><span class="text_5">In addition to the external authentication providers listed previously, third-party packages are available that provide middleware for using many more external authentication providers. For a list, see the </span><a href="https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src" class="text_4">AspNet.Security.OAuth.Providers</a><span class="text_5"> repo on GitHub.</span></p>
	<p class="block_14">You can also create your own external authentication middleware to solve some special need.</p>
	<h3 id="id_Toc534713873" class="block_19">Authenticate with bearer tokens</h3>
	<p class="block_14">Authenticating with ASP.NET Core Identity (or Identity plus external authentication providers) works well for many web application scenarios in which storing user information in a cookie is appropriate. In other scenarios, though, cookies are not a natural means of persisting and transmitting data.</p>
	<p class="block_17"><span class="text_5">For example, in an ASP.NET Core Web API that exposes RESTful endpoints that might be accessed by Single Page Applications (SPAs), by native clients, or even by other Web APIs, you typically want to use bearer token authentication instead. These types of applications do not work with cookies, but can easily retrieve a bearer token and include it in the authorization header of subsequent requests. To enable token authentication, ASP.NET Core supports several options for using </span><a href="https://oauth.net/2/" class="text_4">OAuth 2.0</a><span class="text_5"> and </span><a href="https://openid.net/connect/" class="text_4">OpenID Connect</a><span class="text_5">.</span></p>
	<h3 id="id_Toc534713874" class="block_19">Authenticate with an OpenID Connect or OAuth 2.0 Identity provider</h3>
	<p class="block_27"><span class="text_8">If user information is stored in Azure Active Directory or another identity solution that supports OpenID Connect or OAuth 2.0, you can use the </span><span class="text_17">Microsoft.AspNetCore.Authentication.OpenIdConnect</span><span class="text_8"> package to authenticate using the OpenID Connect workflow. For example, to authenticate to the Identity.Api microservice in eShopOnContainers, an ASP.NET Core web application can use middleware from that <img src="images/image316.tiff" alt="Image" class="calibre195"/>package as shown in the following simplified example in </span><span class="text_9">Startup.cs</span><span class="text_8">:</span></p>
	<p class="block_14">Note that when you use this workflow, the ASP.NET Core Identity middleware is not needed, because all user information storage and authentication is handled by the Identity service.</p>
	<h3 id="id_Toc534713875" class="block_19">Issue security tokens from an ASP.NET Core service</h3>
	<p class="block_14">If you prefer to issue security tokens for local ASP.NET Core Identity users rather than using an external identity provider, you can take advantage of some good third-party libraries.</p>
	<p class="block_17"><a href="https://github.com/IdentityServer/IdentityServer4" class="text_4">IdentityServer4</a><span class="text_5"> and </span><a href="https://github.com/openiddict/openiddict-core" class="text_4">OpenIddict</a><span class="text_5"> are OpenID Connect providers that integrate easily with ASP.NET Core Identity to let you issue security tokens from an ASP.NET Core service. The </span><a href="https://identityserver4.readthedocs.io/en/release/" class="text_4">IdentityServer4 documentation</a><span class="text_5"> has in-depth instructions for using the library. However, the basic steps to using IdentityServer4 to issue tokens are as follows.</span></p>
	<ol class="list_1">
	<li class="block_25">You call app.UseIdentityServer in the Startup.Configure method to add IdentityServer4 to the application’s HTTP request processing pipeline. This lets the library serve requests to OpenID Connect and OAuth2 endpoints like /connect/token.</li>
	<li class="block_25">You configure IdentityServer4 in Startup.ConfigureServices by making a call to services.AddIdentityServer.</li>
	<li class="block_25">You configure identity server by setting the following data:</li>
</ol>
	<div class="calibre62">
	<div class="block_40">– <span class="text_">The </span><a href="https://identityserver4.readthedocs.io/en/release/topics/crypto.html" class="text_1">credentials</a><span class="text_"> to use for signing.</span></div>
	<div class="block_40">– <span class="text_">The </span><a href="https://identityserver4.readthedocs.io/en/release/topics/resources.html" class="text_1">Identity and API resources</a><span class="text_"> that users might request access to:</span></div>
</div>
	<div class="calibre279">
	<div class="block_30">• API resources represent protected data or functionality that a user can access with an access token. An example of an API resource would be a web API (or set of APIs) that requires authorization.</div>
	<div class="block_30">• Identity resources represent information (claims) that are given to a client to identify a user. The claims might include the user name, email address, and so on.</div>
</div>
	<div class="calibre62">
	<div class="block_40">– <span class="text_">The </span><a href="https://identityserver4.readthedocs.io/en/release/topics/clients.html" class="text_1">clients</a><span class="text_"> that will be connecting in order to request tokens.</span></div>
	<div class="block_40">– <span class="text_">The storage mechanism for user information, such as </span><a href="https://identityserver4.readthedocs.io/en/release/quickstarts/6_aspnet_identity.html" class="text_1">ASP.NET Core Identity</a><span class="text_"> or an alternative.</span></div>
</div>
	<p class="block_17"><span class="text_5">When you specify clients and resources for IdentityServer4 to use, you can pass an </span><a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=netcore-2.1" class="text_4">IEnumerable&lt;T&gt;</a><span class="text_5"> collection of the appropriate type to methods that take in-memory client or resource stores. Or for more complex scenarios, you can provide client or resource provider types via Dependency Injection.</span></p>
	<p class="block_14"><img src="images/image317.tiff" alt="Image" class="calibre260"/>A sample configuration for IdentityServer4 to use in-memory resources and clients provided by a custom IClientStore type might look like the following example:</p>
	<h3 id="id_Toc534713876" class="block_19">Consume security tokens</h3>
	<p class="block_14">Authenticating against an OpenID Connect endpoint or issuing your own security tokens covers some scenarios. But what about a service that simply needs to limit access to those users who have valid security tokens that were provided by a different service?</p>
	<p class="block_17"><span class="text_5">For that scenario, authentication middleware that handles JWT tokens is available in the </span><span class="text_7">Microsoft.AspNetCore.Authentication.JwtBearer</span><span class="text_5"> package. JWT stands for “</span><a href="https://tools.ietf.org/html/rfc7519" class="text_4">JSON Web Token</a><span class="text_5">” and is a common security token format (defined by RFC 7519) for communicating security claims. A simplified example of how to use middleware to consume such tokens might look like this code fragment, taken from the Ordering.Api microservice of eShopOnContainers.</span></p>
	<p class="block_15"> </p>
	<p class="block_15"> </p>
	<p class="block_14"><img src="images/image318.tiff" alt="Image" class="calibre278"/>The parameters in this usage are:</p>
	<ul class="list_">
	<li class="block_32"><span class="text_15">Audience</span><span class="text_16"> represents the receiver of the incoming token or the resource that the token grants access to. If the value specified in this parameter does not match the parameter in the token, the token will be rejected.</span></li>
	<li class="block_32"><span class="text_15">Authority</span><span class="text_16"> is the address of the token-issuing authentication server. The JWT bearer authentication middleware uses this URI to get the public key that can be used to validate the token’s signature. The middleware also confirms that the </span><span class="text_15">iss</span><span class="text_16"> parameter in the token matches this URI.</span></li>
</ul>
	<p class="block_27"><span class="text_8">Another parameter, </span><span class="text_9">RequireHttpsMetadata</span><span class="text_8">, is useful for testing purposes; you set this parameter to false so you can test in environments where you don’t have certificates. In real-world deployments, JWT bearer tokens should always be passed only over HTTPS.</span></p>
	<p class="block_27"><span class="text_8">With this middleware in place, JWT tokens are automatically extracted from authorization headers. They are then deserialized, validated (using the values in the </span><span class="text_9">Audience</span><span class="text_8"> and </span><span class="text_9">Authority</span><span class="text_8"> parameters), and stored as user information to be referenced later by MVC actions or authorization filters.</span></p>
	<p class="block_27"><span class="text_8">The JWT bearer authentication middleware can also support more advanced scenarios, such as using a local certificate to validate a token if the authority is not available. For this scenario, you can specify a </span><span class="text_9">TokenValidationParameters</span><span class="text_8"> object in the </span><span class="text_9">JwtBearerOptions</span><span class="text_8"> object.</span></p>
	<h2 id="id_Toc534713877" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Sharing cookies between applications</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/data-protection/compatibility/cookie-sharing" class="text_1">https://docs.microsoft.com/aspnet/core/security/data-protection/compatibility/cookie-sharing#sharing-authentication-cookies-between-applications</a></li>
	<li class="block_20"><span class="text_2">Introduction to Identity</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity" class="text_1">https://docs.microsoft.com/aspnet/core/security/authentication/identity</a></li>
	<li class="block_20"><span class="text_2">Rick Anderson. Two-factor authentication with SMS</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/2fa" class="text_1">https://docs.microsoft.com/aspnet/core/security/authentication/2fa</a></li>
	<li class="block_20"><span class="text_2">Enabling authentication using Facebook, Google and other external providers</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/social/" class="text_1">https://docs.microsoft.com/aspnet/core/security/authentication/social/</a></li>
	<li class="block_20"><span class="text_2">Michell Anicas. An Introduction to OAuth 2</span><span class="text_"><br class="calibre6"/></span><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2" class="text_1">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></li>
	<li class="block_20"><span class="text_2">AspNet.Security.OAuth.Providers</span><span class="text_"> (GitHub repo for ASP.NET OAuth providers.<br class="calibre6"/></span><a href="https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src" class="text_1">https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src</a></li>
	<li class="block_20"><span class="text_2">Danny Strockis. Integrating Azure AD into an ASP.NET Core web app</span><span class="text_"><br class="calibre6"/></span><a href="https://azure.microsoft.com/resources/samples/active-directory-dotnet-webapp-openidconnect-aspnetcore/" class="text_1">https://azure.microsoft.com/resources/samples/active-directory-dotnet-webapp-openidconnect-aspnetcore/</a></li>
	<li class="block_20"><span class="text_2">IdentityServer4. Official documentation</span><span class="text_"><br class="calibre6"/></span><a href="https://identityserver4.readthedocs.io/en/release/" class="text_1">https://identityserver4.readthedocs.io/en/release/</a></li>
</ul>
	<h1 id="id_Toc534713878" class="block_24">About authorization in .NET microservices and web applications</h1>
	<p class="block_17"><span class="text_5">After authentication, ASP.NET Core Web APIs need to authorize access. This process allows a service to make APIs available to some authenticated users, but not to all. </span><a href="https://docs.microsoft.com/aspnet/core/security/authorization/introduction" class="text_4">Authorization</a><span class="text_5"> can be done based on users’ roles or based on custom policy, which might include inspecting claims or other heuristics.</span></p>
	<p class="block_14"><img src="images/image319.tiff" alt="Image" class="calibre280"/>Restricting access to an ASP.NET Core MVC route is as easy as applying an Authorize attribute to the action method (or to the controller’s class if all the controller’s actions require authorization), as shown in following example:</p>
	<p class="block_14">By default, adding an Authorize attribute without parameters will limit access to authenticated users for that controller or action. To further restrict an API to be available for only specific users, the attribute can be expanded to specify required roles or policies that users must satisfy.</p>
	<h2 id="id_Toc534713879" class="block_18">Implement role-based authorization</h2>
	<p class="block_27"><span class="text_8">ASP.NET Core Identity has a built-in concept of roles. In addition to users, ASP.NET Core Identity stores information about different roles used by the application and keeps track of which users are assigned to which roles. These assignments can be changed programmatically with the </span><span class="text_9">RoleManager</span><span class="text_8"> type that updates roles in persisted storage, and the </span><span class="text_9">UserManager</span><span class="text_8"> type that can grant or revoke roles from users.</span></p>
	<p class="block_14"><img src="images/image320.tiff" alt="Image" class="calibre225"/>If you’re authenticating with JWT bearer tokens, the ASP.NET Core JWT bearer authentication middleware will populate a user’s roles based on role claims found in the token. To limit access to an MVC action or controller to users in specific roles, you can include a Roles parameter in the Authorize annotation (attribute), as shown in the following code fragment:</p>
	<p class="block_14">In this example, only users in the Administrator or PowerUser roles can access APIs in the ControlPanel controller (such as executing the SetTime action). The ShutDown API is further restricted to allow access only to users in the Administrator role.</p>
	<p class="block_14"><img src="images/image321.tiff" alt="Image" class="calibre281"/>To require a user be in multiple roles, you use multiple Authorize attributes, as shown in the following example: </p>
	<p class="block_14">In this example, to call API1, a user must:</p>
	<ul class="list_">
	<li class="block_25">Be in the Administrator <i class="calibre8">or</i> PowerUser role, <i class="calibre8">and</i></li>
	<li class="block_25">Be in the RemoteEmployee role, <i class="calibre8">and</i></li>
	<li class="block_25">Satisfy a custom handler for CustomPolicy authorization.</li>
</ul>
	<h2 id="id_Toc534713880" class="block_18">Implement policy-based authorization</h2>
	<p class="block_17"><span class="text_5">Custom authorization rules can also be written using </span><a href="https://docs.asp.net/en/latest/security/authorization/policies.html" class="text_4">authorization policies</a><span class="text_5">. This section provides an overview. For more information, see the </span><a href="https://github.com/blowdart/AspNetAuthorizationWorkshop" class="text_4">ASP.NET Authorization Workshop</a><span class="text_5">.</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image322.tiff" alt="Image" class="calibre282"/>Custom authorization policies are registered in the Startup.ConfigureServices method using the service </span><span class="text_9">AddAuthorization</span><span class="text_8"> method. This method takes a delegate that configures an AuthorizationOptions argument. </span></p>
	<p class="block_27"><span class="text_8">As shown in the example, policies can be associated with different types of requirements. After the policies are registered, they can be applied to an action or controller by passing the policy’s name as the Policy argument of the Authorize attribute (for example, </span><span class="text_9">[Authorize(Policy=“EmployeesOnly”)]</span><span class="text_8">) Policies can have multiple requirements, not just one (as shown in these examples).</span></p>
	<p class="block_27"><span class="text_8">In the previous example, the first AddPolicy call is just an alternative way of authorizing by role. If </span><span class="text_9">[Authorize(Policy=“AdministratorsOnly”)]</span><span class="text_8"> is applied to an API, only users in the Administrator role will be able to access it.</span></p>
	<p class="block_17"><span class="text_5">The second </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationoptions.addpolicy?view=aspnetcore-2.1" class="text_4">AddPolicy</a><span class="text_5"> call demonstrates an easy way to require that a particular claim should be present for the user. The </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationpolicybuilder.requireclaim?view=aspnetcore-2.1" class="text_4">RequireClaim</a><span class="text_5"> method also optionally takes expected values for the claim. If values are specified, the requirement is met only if the user has both a claim of the correct type and one of the specified values. If you’re using the JWT bearer authentication middleware, all JWT properties will be available as user claims.</span></p>
	<p class="block_27"><span class="text_8">The most interesting policy shown here is in the third </span><span class="text_9">AddPolicy</span><span class="text_8"> method, because it uses a custom authorization requirement. By using custom authorization requirements, you can have a great deal of control over how authorization is performed. For this to work, you must implement these types:</span></p>
	<ul class="list_">
	<li class="block_41"><span class="text_29">A Requirements type that derives from </span><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationrequirement?view=aspnetcore-2.1" class="text_30">IAuthorizationRequirement</a><span class="text_29"> and that contains fields specifying the details of the requirement. In the example, this is an age field for the sample </span><span class="text_31">MinimumAgeRequirement</span><span class="text_29"> type.</span></li>
	<li class="block_20"><span class="text_">A handler that implements </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationhandler-1?view=aspnetcore-2.1" class="text_1">AuthorizationHandler&lt;TRequirement&gt;</a><span class="text_">, where T is the type of </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.iauthorizationrequirement?view=aspnetcore-2.1" class="text_1">IAuthorizationRequirement</a><span class="text_"> that the handler can satisfy. The handler must implement the </span><a href="https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.authorization.authorizationhandler-1.handlerequirementasync?view=aspnetcore-2.1" class="text_1">HandleRequirementAsync()</a><span class="text_"> method, which checks whether a specified context that contains information about the user satisfies the requirement.</span></li>
</ul>
	<p class="block_27"><span class="text_8">If the user meets the requirement, a call to </span><span class="text_9">context.Succeed</span><span class="text_8"> will indicate that the user is authorized. If there are multiple ways that a user might satisfy an authorization requirement, multiple handlers can be created.</span></p>
	<p class="block_27"><span class="text_8">In addition to registering custom policy requirements with </span><span class="text_9">AddPolicy</span><span class="text_8"> calls, you also need to register custom requirement handlers via Dependency Injection (</span><span class="text_9">services.AddTransient&lt;IAuthorizationHandler, MinimumAgeHandler&gt;()</span><span class="text_8">).</span></p>
	<p class="block_15"><span class="text_12">An example of a custom authorization requirement and handler for checking a user’s age (based on a </span><span class="text_13">DateOfBirth</span><span class="text_12"> claim) is available in the ASP.NET Core </span><a href="https://docs.asp.net/en/latest/security/authorization/policies.html" class="text_14">authorization documentation</a><span class="text_12">.</span></p>
	<h2 id="id_Toc534713881" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">ASP.NET Core Authentication</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authentication/identity" class="text_1">https://docs.microsoft.com/aspnet/core/security/authentication/identity</a></li>
	<li class="block_20"><span class="text_2">ASP.NET Core Authorization</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authorization/introduction" class="text_1">https://docs.microsoft.com/aspnet/core/security/authorization/introduction</a></li>
	<li class="block_20"><span class="text_2">Role-based Authorization</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authorization/roles" class="text_1">https://docs.microsoft.com/aspnet/core/security/authorization/roles</a></li>
	<li class="block_20"><span class="text_2">Custom Policy-Based Authorization</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/authorization/policies" class="text_1">https://docs.microsoft.com/aspnet/core/security/authorization/policies</a></li>
</ul>
	<h1 id="id_Toc534713882" class="block_24">Store application secrets safely during development</h1>
	<p class="block_14">To connect with protected resources and other services, ASP.NET Core applications typically need to use connection strings, passwords, or other credentials that contain sensitive information. These sensitive pieces of information are called <i class="calibre15">secrets</i>. It’s a best practice to not include secrets in source code and making sure not to store secrets in source control. Instead, you should use the ASP.NET Core configuration model to read the secrets from more secure locations.</p>
	<p class="block_14">You must separate the secrets for accessing development and staging resources from the ones used for accessing production resources, because different individuals will need access to those different sets of secrets. To store secrets used during development, common approaches are to either store secrets in environment variables or by using the ASP.NET Core Secret Manager tool. For more secure storage in production environments, microservices can store secrets in an Azure Key Vault.</p>
	<h2 id="id_Toc534713883" class="block_18">Store secrets in environment variables</h2>
	<p class="block_17"><span class="text_5">One way to keep secrets out of source code is for developers to set string-based secrets as </span><a href="https://docs.microsoft.com/aspnet/core/security/app-secrets" class="text_4">environment variables</a><span class="text_5"> on their development machines. When you use environment variables to store secrets with hierarchical names, such as the ones nested in configuration sections, you must name the variables to include the complete hierarchy of its sections, delimited with colons (:).</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image323.tiff" alt="Image" class="calibre111"/>For example, setting an environment variable </span><span class="text_9">Logging:LogLevel:Default</span><span class="text_8"> to </span><span class="text_9">Debug</span><span class="text_8"> value would be equivalent to a configuration value from the following JSON file: </span></p>
	<p class="block_14">To access these values from environment variables, the application just needs to call AddEnvironmentVariables on its ConfigurationBuilder when constructing an IConfigurationRoot object.</p>
	<p class="block_14">Note that environment variables are commonly stored as plain text, so if the machine or process with the environment variables is compromised, the environment variable values will be visible.</p>
	<h2 id="id_Toc534713884" class="block_18">Store secrets with the ASP.NET Core Secret Manager</h2>
	<p class="block_15"><span class="text_12">The ASP.NET Core </span><a href="https://docs.microsoft.com/aspnet/core/security/app-secrets" class="text_14">Secret Manager</a><span class="text_12"> tool provides another method of keeping secrets out of source code. To use the Secret Manager tool, install the package </span><span class="text_24">Microsoft.Extensions.Configuration.SecretManager</span><span class="text_12"> in your project file. Once that dependency is present and has been restored, the </span><span class="text_13">dotnet user-secrets</span><span class="text_12"> command can be used to set the value of secrets from the command line. These secrets will be stored in a JSON file in the user’s profile directory (details vary by OS), away from source code.</span></p>
	<p class="block_27"><span class="text_8"><img src="images/image324.tiff" alt="Image" class="calibre283"/>Secrets set by the Secret Manager tool are organized by the </span><span class="text_9">UserSecretsId</span><span class="text_8"> property of the project that’s using the secrets. Therefore, you must be sure to set the UserSecretsId property in your project file, as shown in the snippet below. The default value is a GUID assigned by Visual Studio, but the actual string is not important as long as it’s unique in your computer.</span></p>
	<p class="block_27"><span class="text_8">Using secrets stored with Secret Manager in an application is accomplished by calling </span><span class="text_9">AddUserSecrets</span><span class="text_8"> on the ConfigurationBuilder instance to include secrets for the application in its configuration. The generic parameter T should be a type from the assembly that the UserSecretId was applied to. Usually using </span><span class="text_9">AddUserSecrets</span><span class="text_8"> is fine.</span></p>
	<p class="block_14">The AddUserSecrets&lt;Startup&gt;() is included in the default options for the Development environment when using the CreateDefaultBuilder method in Program.cs.</p>
	<h1 id="id_Toc534713885" class="block_24">Use Azure Key Vault to protect secrets at production time</h1>
	<p class="block_17"><span class="text_5">Secrets stored as environment variables or stored by the Secret Manager tool are still stored locally and unencrypted on the machine. A more secure option for storing secrets is </span><a href="https://azure.microsoft.com/services/key-vault/" class="text_4">Azure Key Vault</a><span class="text_5">, which provides a secure, central location for storing keys and secrets.</span></p>
	<p class="block_14">The <b class="calibre5">Microsoft.Extensions.Configuration.AzureKeyVault</b> package allows an ASP.NET Core application to read configuration information from Azure Key Vault. To start using secrets from an Azure Key Vault, you follow these steps:</p>
	<ol class="list_1">
	<li class="block_25">Register your application as an Azure AD application. (Access to key vaults is managed by Azure AD.) This can be done through the Azure management portal.</li>
</ol>
	<div class="calibre60">
	<div class="block_40"> <span class="text_">Alternatively, if you want your application to authenticate using a certificate instead of a password or client secret, you can use the </span><a href="https://docs.microsoft.com/powershell/module/azurerm.resources/new-azurermadapplication" class="text_1">New-AzureRmADApplication</a><span class="text_"> PowerShell cmdlet. The certificate that you register with Azure Key Vault needs only your public key. (Your application will use the private key.)</span></div>
</div>
	<ol class="list_1">
	<li value="2" class="block_25"><img src="images/image325.tiff" alt="Image" class="calibre284"/>Give the registered application access to the key vault by creating a new service principal. You can do this using the following PowerShell commands: </li>
	<li class="block_41"><span class="text_29">Include the key vault as a configuration source in your application by calling the </span><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.azurekeyvaultconfigurationextensions.addazurekeyvault?view=aspnetcore-2.1" class="text_30">AzureKeyVaultConfigurationExtensions.AddAzureKeyVault</a><span class="text_29"> extension method when you create an </span><a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.iconfigurationroot?view=aspnetcore-2.1" class="text_30">IConfigurationRoot</a><span class="text_29"> instance. Note that calling </span><span class="text_31">AddAzureKeyVault</span><span class="text_29"> will require the application ID that was registered and given access to the key vault in the previous steps.</span></li>
</ol>
	<div class="calibre60">
	<div class="block_42"> <span class="text_29">You can also use an overload of </span><span class="text_31">AddAzureKeyVault</span><span class="text_29"> that takes a certificate in place of the client secret by just including a reference to the </span><a href="https://www.nuget.org/packages/Microsoft.IdentityModel.Clients.ActiveDirectory" class="text_30">Microsoft.IdentityModel.Clients.ActiveDirectory</a><span class="text_29"> package.</span></div>
</div>
	<p class="block_14"><b class="calibre5">IMPORTANT:</b> It’s a best practice to register Azure Key Vault as the last configuration provider so it can override configuration values from previous providers.</p>
	<h2 id="id_Toc534713886" class="block_18">Additional resources</h2>
	<ul class="list_">
	<li class="block_20"><span class="text_2">Using Azure Key Vault to protect application secrets</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/azure/guidance/guidance-multitenant-identity-keyvault" class="text_1">https://docs.microsoft.com/azure/guidance/guidance-multitenant-identity-keyvault</a></li>
	<li class="block_20"><span class="text_2">Safe storage of app secrets during development</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/app-secrets" class="text_1">https://docs.microsoft.com/aspnet/core/security/app-secrets</a></li>
	<li class="block_20"><span class="text_2">Configuring data protection</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/data-protection/configuration/overview" class="text_1">https://docs.microsoft.com/aspnet/core/security/data-protection/configuration/overview</a></li>
	<li class="block_20"><span class="text_2">Key management and lifetime</span><span class="text_"><br class="calibre6"/></span><a href="https://docs.microsoft.com/aspnet/core/security/data-protection/configuration/default-settings" class="text_1">https://docs.microsoft.com/aspnet/core/security/data-protection/configuration/default-settings#data-protection-default-settings</a></li>
	<li class="block_20"><span class="text_2">Microsoft.Extensions.Configuration.KeyPerFile</span><span class="text_"> GitHub repo.<br class="calibre6"/></span><a href="https://github.com/aspnet/Configuration/tree/master/src/Config.KeyPerFile" class="text_1">https://github.com/aspnet/Configuration/tree/master/src/Config.KeyPerFile</a></li>
</ul>
	<p class="block_15"> </p>
	</body></html>
